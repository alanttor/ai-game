<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é€’å½’åˆ†æ²»é­”æ³•æ‹¼å›¾</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ”®</text></svg>">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: linear-gradient(135deg, #1a0a2e 0%, #2d1b4e 50%, #1a0a2e 100%);
            min-height: 100vh;
            color: #fff;
            overflow: hidden;
        }
        .container {
            display: flex;
            height: 100vh;
            padding: 15px;
            gap: 15px;
        }
        .main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        header {
            text-align: center;
            padding: 10px;
            background: rgba(0,0,0,0.3);
            border-radius: 12px;
            border: 1px solid #a855f7;
        }
        h1 {
            font-size: 1.5em;
            background: linear-gradient(90deg, #a855f7, #ec4899, #a855f7);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        .canvas-container {
            flex: 1;
            background: rgba(0,0,0,0.4);
            border-radius: 15px;
            border: 2px solid #a855f755;
            position: relative;
            overflow: hidden;
        }
        #mainCanvas { display: block; width: 100%; height: 100%; }
</style>
</head>
<body>
<div class="container">
    <div class="main-area">
        <header>
            <h1>ğŸ”® é€’å½’åˆ†æ²»é­”æ³•æ‹¼å›¾</h1>
            <p style="color:#a855f7;font-size:0.85em;margin-top:5px;">æ¢ç´¢é€’å½’çš„å¥¥ç§˜ï¼Œè§£é”åˆ†æ²»çš„åŠ›é‡</p>
        </header>
        <div class="canvas-container">
            <canvas id="mainCanvas"></canvas>
        </div>
    </div>
    <div class="control-panel" id="controlPanel"></div>
</div>
<script>
// æ¸¸æˆçŠ¶æ€
const state = {
    mode: 'hanoi',
    running: false,
    paused: false,
    speed: 50,
    depth: 4,
    callStack: [],
    stats: { calls: 0, maxDepth: 0 }
};

// æ¨¡å¼é…ç½®
const MODES = {
    hanoi: { name: 'æ±‰è¯ºå¡”', icon: 'ğŸ—¼', color: '#f59e0b', desc: 'ç»å…¸é€’å½’é—®é¢˜ï¼Œå°†æ‰€æœ‰åœ†ç›˜ä»AæŸ±ç§»åˆ°CæŸ±' },
    koch: { name: 'ç§‘èµ«é›ªèŠ±', icon: 'â„ï¸', color: '#3b82f6', desc: 'é€’å½’ç»˜åˆ¶åˆ†å½¢é›ªèŠ±å›¾æ¡ˆ' },
    sierpinski: { name: 'è°¢å°”å®¾æ–¯åŸº', icon: 'ğŸ”º', color: '#10b981', desc: 'é€’å½’ç»˜åˆ¶ä¸‰è§’å½¢åˆ†å½¢' },
    tree: { name: 'åˆ†å½¢æ ‘', icon: 'ğŸŒ³', color: '#22c55e', desc: 'é€’å½’ç»˜åˆ¶è‡ªç„¶åˆ†å½¢æ ‘' },
    carpet: { name: 'è°¢å°”å®¾æ–¯åŸºåœ°æ¯¯', icon: 'ğŸŸª', color: '#8b5cf6', desc: 'é€’å½’ç»˜åˆ¶æ­£æ–¹å½¢åˆ†å½¢' },
    dragon: { name: 'é¾™å½¢æ›²çº¿', icon: 'ğŸ‰', color: '#ef4444', desc: 'é€’å½’ç»˜åˆ¶é¾™å½¢åˆ†å½¢æ›²çº¿' }
};

// æ±‰è¯ºå¡”çŠ¶æ€
let hanoiState = { pegs: [[], [], []], moves: [], moveIndex: 0, diskCount: 4 };

// åˆå§‹åŒ–
let canvas, ctx;
function init() {
    canvas = document.getElementById('mainCanvas');
    ctx = canvas.getContext('2d');
    resizeCanvas();
    renderControlPanel();
    draw();
    window.addEventListener('resize', resizeCanvas);
}

function resizeCanvas() {
    const container = canvas.parentElement;
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
    draw();
}

// æ¸²æŸ“æ§åˆ¶é¢æ¿
function renderControlPanel() {
    const panel = document.getElementById('controlPanel');
    panel.innerHTML = `
        <style>
            .control-panel {
                width: 280px;
                background: rgba(0,0,0,0.5);
                border-radius: 15px;
                padding: 15px;
                border: 1px solid #a855f755;
                display: flex;
                flex-direction: column;
                gap: 12px;
                overflow-y: auto;
            }
            .panel-section {
                background: rgba(255,255,255,0.05);
                border-radius: 10px;
                padding: 12px;
            }
            .section-title {
                color: #a855f7;
                font-size: 0.9em;
                margin-bottom: 10px;
                display: flex;
                align-items: center;
                gap: 5px;
            }
            .mode-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
            .mode-btn {
                background: rgba(255,255,255,0.1);
                border: 2px solid transparent;
                border-radius: 8px;
                padding: 10px 8px;
                cursor: pointer;
                transition: all 0.3s;
                text-align: center;
                color: #fff;
            }
            .mode-btn:hover { background: rgba(255,255,255,0.2); }
            .mode-btn.active { border-color: var(--color); box-shadow: 0 0 15px var(--color); }
            .mode-icon { font-size: 1.5em; display: block; margin-bottom: 3px; }
            .mode-name { font-size: 0.75em; }
            .slider-group { margin-bottom: 12px; }
            .slider-label { display: flex; justify-content: space-between; font-size: 0.85em; color: #aaa; margin-bottom: 5px; }
            input[type="range"] {
                width: 100%; height: 6px; border-radius: 3px;
                background: #333; outline: none; -webkit-appearance: none;
            }
            input[type="range"]::-webkit-slider-thumb {
                -webkit-appearance: none; width: 16px; height: 16px;
                border-radius: 50%; background: #a855f7; cursor: pointer;
            }
            .btn-group { display: flex; gap: 8px; flex-wrap: wrap; }
            .ctrl-btn {
                flex: 1; min-width: 70px; padding: 10px; border: none;
                border-radius: 8px; cursor: pointer; font-size: 0.9em;
                transition: all 0.3s; color: #fff;
            }
            .btn-primary { background: linear-gradient(135deg, #a855f7, #ec4899); }
            .btn-secondary { background: rgba(255,255,255,0.1); }
            .ctrl-btn:hover { transform: translateY(-2px); }
            .ctrl-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
            .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
            .stat-box { background: rgba(0,0,0,0.3); border-radius: 8px; padding: 10px; text-align: center; }
            .stat-value { font-size: 1.3em; color: #a855f7; font-weight: bold; }
            .stat-label { font-size: 0.7em; color: #888; }
            .call-stack {
                background: rgba(0,0,0,0.3);
                border-radius: 8px;
                padding: 10px;
                max-height: 150px;
                overflow-y: auto;
                font-family: monospace;
                font-size: 0.75em;
            }
            .stack-item {
                padding: 4px 8px;
                margin: 2px 0;
                background: rgba(168,85,247,0.2);
                border-radius: 4px;
                border-left: 3px solid #a855f7;
            }
            .info-box {
                background: rgba(0,0,0,0.3);
                border-radius: 8px;
                padding: 10px;
                font-size: 0.8em;
                line-height: 1.5;
                color: #aaa;
                border-left: 3px solid #a855f7;
            }
        </style>
        <div class="panel-section">
            <div class="section-title">ğŸ® é€‰æ‹©æ¨¡å¼</div>
            <div class="mode-grid" id="modeGrid"></div>
        </div>
        <div class="panel-section">
            <div class="section-title">âš™ï¸ å‚æ•°è®¾ç½®</div>
            <div class="slider-group">
                <div class="slider-label"><span>é€’å½’æ·±åº¦</span><span id="depthVal">${state.depth}</span></div>
                <input type="range" id="depthSlider" min="1" max="8" value="${state.depth}">
            </div>
            <div class="slider-group">
                <div class="slider-label"><span>åŠ¨ç”»é€Ÿåº¦</span><span id="speedVal">${state.speed}%</span></div>
                <input type="range" id="speedSlider" min="1" max="100" value="${state.speed}">
            </div>
        </div>
        <div class="panel-section">
            <div class="section-title">ğŸ¬ æ§åˆ¶</div>
            <div class="btn-group">
                <button class="ctrl-btn btn-primary" id="startBtn" onclick="startAnimation()">â–¶ï¸ å¼€å§‹</button>
                <button class="ctrl-btn btn-secondary" id="pauseBtn" onclick="togglePause()" disabled>â¸ï¸</button>
                <button class="ctrl-btn btn-secondary" id="resetBtn" onclick="resetAnimation()">ğŸ”„</button>
            </div>
            <div class="btn-group" style="margin-top:8px;">
                <button class="ctrl-btn btn-secondary" id="stepBtn" onclick="stepAnimation()">â­ï¸ å•æ­¥</button>
            </div>
        </div>
        <div class="panel-section">
            <div class="section-title">ğŸ“Š ç»Ÿè®¡</div>
            <div class="stats-grid">
                <div class="stat-box"><div class="stat-value" id="callCount">0</div><div class="stat-label">é€’å½’è°ƒç”¨</div></div>
                <div class="stat-box"><div class="stat-value" id="maxDepth">0</div><div class="stat-label">æœ€å¤§æ·±åº¦</div></div>
            </div>
        </div>
        <div class="panel-section">
            <div class="section-title">ğŸ“š è°ƒç”¨æ ˆ</div>
            <div class="call-stack" id="callStack">ç­‰å¾…å¼€å§‹...</div>
        </div>
        <div class="panel-section">
            <div class="section-title">ğŸ’¡ è¯´æ˜</div>
            <div class="info-box" id="infoBox">${MODES[state.mode].desc}</div>
        </div>
    `;
    
    // æ¸²æŸ“æ¨¡å¼æŒ‰é’®
    const modeGrid = document.getElementById('modeGrid');
    Object.entries(MODES).forEach(([key, mode]) => {
        const btn = document.createElement('button');
        btn.className = `mode-btn ${state.mode === key ? 'active' : ''}`;
        btn.style.setProperty('--color', mode.color);
        btn.innerHTML = `<span class="mode-icon">${mode.icon}</span><span class="mode-name">${mode.name}</span>`;
        btn.onclick = () => selectMode(key);
        modeGrid.appendChild(btn);
    });
    
    // ç»‘å®šäº‹ä»¶
    document.getElementById('depthSlider').oninput = (e) => {
        state.depth = parseInt(e.target.value);
        document.getElementById('depthVal').textContent = state.depth;
        if (!state.running) { resetAnimation(); draw(); }
    };
    document.getElementById('speedSlider').oninput = (e) => {
        state.speed = parseInt(e.target.value);
        document.getElementById('speedVal').textContent = state.speed + '%';
    };
}

function selectMode(mode) {
    state.mode = mode;
    state.running = false;
    state.paused = false;
    resetStats();
    renderControlPanel();
    draw();
}

function resetStats() {
    state.stats = { calls: 0, maxDepth: 0 };
    state.callStack = [];
    updateStats();
}

function updateStats() {
    document.getElementById('callCount').textContent = state.stats.calls;
    document.getElementById('maxDepth').textContent = state.stats.maxDepth;
    
    const stackEl = document.getElementById('callStack');
    if (state.callStack.length === 0) {
        stackEl.innerHTML = 'ç­‰å¾…å¼€å§‹...';
    } else {
        stackEl.innerHTML = state.callStack.map(s => `<div class="stack-item">${s}</div>`).join('');
        stackEl.scrollTop = stackEl.scrollHeight;
    }
}

function pushStack(msg) {
    state.callStack.push(msg);
    state.stats.calls++;
    state.stats.maxDepth = Math.max(state.stats.maxDepth, state.callStack.length);
    updateStats();
}

function popStack() {
    state.callStack.pop();
    updateStats();
}

// å»¶è¿Ÿå‡½æ•°
function delay() {
    return new Promise(r => setTimeout(r, Math.max(10, 500 - state.speed * 4.5)));
}

// æ£€æŸ¥æš‚åœ
async function checkPause() {
    while (state.paused && state.running) {
        await new Promise(r => setTimeout(r, 100));
    }
    if (!state.running) throw new Error('stopped');
}

// ç»˜åˆ¶ä¸»å‡½æ•°
function draw() {
    ctx.fillStyle = '#1a0a2e';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // ç»˜åˆ¶é­”æ³•èƒŒæ™¯
    drawMagicBackground();
    
    switch (state.mode) {
        case 'hanoi': drawHanoi(); break;
        case 'koch': drawKochStatic(); break;
        case 'sierpinski': drawSierpinskiStatic(); break;
        case 'tree': drawTreeStatic(); break;
        case 'carpet': drawCarpetStatic(); break;
        case 'dragon': drawDragonStatic(); break;
    }
}

// é­”æ³•èƒŒæ™¯
function drawMagicBackground() {
    const time = Date.now() / 2000;
    ctx.save();
    ctx.globalAlpha = 0.1;
    for (let i = 0; i < 5; i++) {
        const x = canvas.width / 2 + Math.cos(time + i) * 100;
        const y = canvas.height / 2 + Math.sin(time + i) * 100;
        const gradient = ctx.createRadialGradient(x, y, 0, x, y, 200);
        gradient.addColorStop(0, '#a855f7');
        gradient.addColorStop(1, 'transparent');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
    }
    ctx.restore();
}

// ========== æ±‰è¯ºå¡” ==========
function initHanoi() {
    hanoiState.diskCount = state.depth + 2;
    hanoiState.pegs = [[], [], []];
    hanoiState.moves = [];
    hanoiState.moveIndex = 0;
    
    for (let i = hanoiState.diskCount; i >= 1; i--) {
        hanoiState.pegs[0].push(i);
    }
    
    // ç”Ÿæˆç§»åŠ¨åºåˆ—
    generateHanoiMoves(hanoiState.diskCount, 0, 2, 1);
}

function generateHanoiMoves(n, from, to, aux) {
    if (n === 0) return;
    generateHanoiMoves(n - 1, from, aux, to);
    hanoiState.moves.push({ disk: n, from, to });
    generateHanoiMoves(n - 1, aux, to, from);
}

function drawHanoi() {
    const pegWidth = 10;
    const pegHeight = canvas.height * 0.5;
    const baseY = canvas.height * 0.8;
    const spacing = canvas.width / 4;
    const maxDiskWidth = spacing * 0.8;
    
    // ç»˜åˆ¶æŸ±å­
    ctx.fillStyle = '#4a3728';
    for (let i = 0; i < 3; i++) {
        const x = spacing * (i + 1);
        ctx.fillRect(x - pegWidth/2, baseY - pegHeight, pegWidth, pegHeight);
        ctx.fillRect(x - maxDiskWidth/2, baseY, maxDiskWidth, 10);
        
        // æ ‡ç­¾
        ctx.fillStyle = '#fff';
        ctx.font = '16px Arial';
        ctx.textAlign = 'center';
        ctx.fillText(['A', 'B', 'C'][i], x, baseY + 30);
        ctx.fillStyle = '#4a3728';
    }
    
    // ç»˜åˆ¶åœ†ç›˜
    const diskHeight = Math.min(30, pegHeight / (hanoiState.diskCount + 1));
    hanoiState.pegs.forEach((peg, pegIndex) => {
        peg.forEach((disk, diskIndex) => {
            const x = spacing * (pegIndex + 1);
            const y = baseY - (diskIndex + 1) * diskHeight;
            const width = (disk / hanoiState.diskCount) * maxDiskWidth * 0.8 + maxDiskWidth * 0.2;
            
            const hue = (disk / hanoiState.diskCount) * 280;
            ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
            ctx.beginPath();
            ctx.roundRect(x - width/2, y, width, diskHeight - 2, 5);
            ctx.fill();
            
            ctx.fillStyle = '#fff';
            ctx.font = '12px Arial';
            ctx.fillText(disk, x, y + diskHeight/2 + 4);
        });
    });
}

async function animateHanoi() {
    initHanoi();
    draw();
    await delay();
    
    for (let i = 0; i < hanoiState.moves.length; i++) {
        await checkPause();
        const move = hanoiState.moves[i];
        pushStack(`ç§»åŠ¨åœ†ç›˜${move.disk}: ${['A','B','C'][move.from]} â†’ ${['A','B','C'][move.to]}`);
        
        // æ‰§è¡Œç§»åŠ¨
        const disk = hanoiState.pegs[move.from].pop();
        hanoiState.pegs[move.to].push(disk);
        
        draw();
        await delay();
        popStack();
    }
}

// ========== ç§‘èµ«é›ªèŠ± ==========
function drawKochStatic() {
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    const size = Math.min(canvas.width, canvas.height) * 0.4;
    
    ctx.strokeStyle = '#3b82f6';
    ctx.lineWidth = 1;
    ctx.beginPath();
    
    // ä¸‰è§’å½¢ä¸‰è¾¹
    const angle = Math.PI * 2 / 3;
    for (let i = 0; i < 3; i++) {
        const x1 = cx + size * Math.cos(i * angle - Math.PI/2);
        const y1 = cy + size * Math.sin(i * angle - Math.PI/2);
        const x2 = cx + size * Math.cos((i+1) * angle - Math.PI/2);
        const y2 = cy + size * Math.sin((i+1) * angle - Math.PI/2);
        drawKochLine(x1, y1, x2, y2, state.depth);
    }
    ctx.stroke();
}

function drawKochLine(x1, y1, x2, y2, depth) {
    if (depth === 0) {
        ctx.lineTo(x2, y2);
        return;
    }
    
    const dx = x2 - x1;
    const dy = y2 - y1;
    
    const ax = x1 + dx / 3;
    const ay = y1 + dy / 3;
    const bx = x1 + dx * 2 / 3;
    const by = y1 + dy * 2 / 3;
    
    const px = (x1 + x2) / 2 + (y1 - y2) * Math.sqrt(3) / 6;
    const py = (y1 + y2) / 2 + (x2 - x1) * Math.sqrt(3) / 6;
    
    drawKochLine(x1, y1, ax, ay, depth - 1);
    drawKochLine(ax, ay, px, py, depth - 1);
    drawKochLine(px, py, bx, by, depth - 1);
    drawKochLine(bx, by, x2, y2, depth - 1);
}

async function animateKoch() {
    for (let d = 0; d <= state.depth; d++) {
        await checkPause();
        pushStack(`ç»˜åˆ¶æ·±åº¦ ${d}`);
        
        ctx.fillStyle = '#1a0a2e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawMagicBackground();
        
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const size = Math.min(canvas.width, canvas.height) * 0.4;
        
        ctx.strokeStyle = '#3b82f6';
        ctx.lineWidth = 2;
        ctx.beginPath();
        
        const angle = Math.PI * 2 / 3;
        const x0 = cx + size * Math.cos(-Math.PI/2);
        const y0 = cy + size * Math.sin(-Math.PI/2);
        ctx.moveTo(x0, y0);
        
        for (let i = 0; i < 3; i++) {
            const x1 = cx + size * Math.cos(i * angle - Math.PI/2);
            const y1 = cy + size * Math.sin(i * angle - Math.PI/2);
            const x2 = cx + size * Math.cos((i+1) * angle - Math.PI/2);
            const y2 = cy + size * Math.sin((i+1) * angle - Math.PI/2);
            drawKochLine(x1, y1, x2, y2, d);
        }
        ctx.stroke();
        
        await delay();
        await delay();
        popStack();
    }
}

// ========== è°¢å°”å®¾æ–¯åŸºä¸‰è§’å½¢ ==========
function drawSierpinskiStatic() {
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;
    const size = Math.min(canvas.width, canvas.height) * 0.4;
    
    const p1 = { x: cx, y: cy - size };
    const p2 = { x: cx - size * Math.cos(Math.PI/6), y: cy + size * Math.sin(Math.PI/6) };
    const p3 = { x: cx + size * Math.cos(Math.PI/6), y: cy + size * Math.sin(Math.PI/6) };
    
    drawSierpinskiTriangle(p1, p2, p3, state.depth);
}

function drawSierpinskiTriangle(p1, p2, p3, depth) {
    if (depth === 0) {
        ctx.fillStyle = '#10b981';
        ctx.beginPath();
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.lineTo(p3.x, p3.y);
        ctx.closePath();
        ctx.fill();
        return;
    }
    
    const m1 = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
    const m2 = { x: (p2.x + p3.x) / 2, y: (p2.y + p3.y) / 2 };
    const m3 = { x: (p3.x + p1.x) / 2, y: (p3.y + p1.y) / 2 };
    
    drawSierpinskiTriangle(p1, m1, m3, depth - 1);
    drawSierpinskiTriangle(m1, p2, m2, depth - 1);
    drawSierpinskiTriangle(m3, m2, p3, depth - 1);
}

async function animateSierpinski() {
    for (let d = 0; d <= state.depth; d++) {
        await checkPause();
        pushStack(`ç»˜åˆ¶æ·±åº¦ ${d}`);
        
        ctx.fillStyle = '#1a0a2e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawMagicBackground();
        
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        const size = Math.min(canvas.width, canvas.height) * 0.4;
        
        const p1 = { x: cx, y: cy - size };
        const p2 = { x: cx - size * Math.cos(Math.PI/6), y: cy + size * Math.sin(Math.PI/6) };
        const p3 = { x: cx + size * Math.cos(Math.PI/6), y: cy + size * Math.sin(Math.PI/6) };
        
        drawSierpinskiTriangle(p1, p2, p3, d);
        
        await delay();
        await delay();
        popStack();
    }
}

// ========== åˆ†å½¢æ ‘ ==========
function drawTreeStatic() {
    const startX = canvas.width / 2;
    const startY = canvas.height * 0.85;
    const length = Math.min(canvas.width, canvas.height) * 0.25;
    
    drawBranch(startX, startY, length, -Math.PI/2, state.depth);
}

function drawBranch(x, y, length, angle, depth) {
    if (depth === 0 || length < 2) return;
    
    const endX = x + length * Math.cos(angle);
    const endY = y + length * Math.sin(angle);
    
    const hue = 120 - depth * 15;
    ctx.strokeStyle = `hsl(${hue}, 60%, ${30 + depth * 8}%)`;
    ctx.lineWidth = depth;
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(endX, endY);
    ctx.stroke();
    
    const newLength = length * 0.7;
    const spread = Math.PI / 6;
    
    drawBranch(endX, endY, newLength, angle - spread, depth - 1);
    drawBranch(endX, endY, newLength, angle + spread, depth - 1);
}

async function animateTree() {
    for (let d = 1; d <= state.depth; d++) {
        await checkPause();
        pushStack(`ç»˜åˆ¶æ·±åº¦ ${d}`);
        
        ctx.fillStyle = '#1a0a2e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawMagicBackground();
        
        const startX = canvas.width / 2;
        const startY = canvas.height * 0.85;
        const length = Math.min(canvas.width, canvas.height) * 0.25;
        
        drawBranch(startX, startY, length, -Math.PI/2, d);
        
        await delay();
        await delay();
        popStack();
    }
}

// ========== è°¢å°”å®¾æ–¯åŸºåœ°æ¯¯ ==========
function drawCarpetStatic() {
    const size = Math.min(canvas.width, canvas.height) * 0.7;
    const x = (canvas.width - size) / 2;
    const y = (canvas.height - size) / 2;
    
    ctx.fillStyle = '#8b5cf6';
    ctx.fillRect(x, y, size, size);
    
    drawCarpetHole(x, y, size, state.depth);
}

function drawCarpetHole(x, y, size, depth) {
    if (depth === 0 || size < 3) return;
    
    const newSize = size / 3;
    
    // æŒ–æ‰ä¸­é—´
    ctx.fillStyle = '#1a0a2e';
    ctx.fillRect(x + newSize, y + newSize, newSize, newSize);
    
    // é€’å½’å¤„ç†8ä¸ªå­åŒºåŸŸ
    for (let i = 0; i < 3; i++) {
        for (let j = 0; j < 3; j++) {
            if (i === 1 && j === 1) continue;
            drawCarpetHole(x + i * newSize, y + j * newSize, newSize, depth - 1);
        }
    }
}

async function animateCarpet() {
    for (let d = 0; d <= state.depth; d++) {
        await checkPause();
        pushStack(`ç»˜åˆ¶æ·±åº¦ ${d}`);
        
        ctx.fillStyle = '#1a0a2e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawMagicBackground();
        
        const size = Math.min(canvas.width, canvas.height) * 0.7;
        const x = (canvas.width - size) / 2;
        const y = (canvas.height - size) / 2;
        
        ctx.fillStyle = '#8b5cf6';
        ctx.fillRect(x, y, size, size);
        
        if (d > 0) drawCarpetHole(x, y, size, d);
        
        await delay();
        await delay();
        popStack();
    }
}

// ========== é¾™å½¢æ›²çº¿ ==========
let dragonPoints = [];

function drawDragonStatic() {
    generateDragon(state.depth);
    
    if (dragonPoints.length < 2) return;
    
    const bounds = getDragonBounds();
    const scale = Math.min(
        canvas.width * 0.8 / (bounds.maxX - bounds.minX),
        canvas.height * 0.8 / (bounds.maxY - bounds.minY)
    );
    const offsetX = canvas.width / 2 - (bounds.minX + bounds.maxX) / 2 * scale;
    const offsetY = canvas.height / 2 - (bounds.minY + bounds.maxY) / 2 * scale;
    
    ctx.strokeStyle = '#ef4444';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(dragonPoints[0].x * scale + offsetX, dragonPoints[0].y * scale + offsetY);
    
    for (let i = 1; i < dragonPoints.length; i++) {
        ctx.lineTo(dragonPoints[i].x * scale + offsetX, dragonPoints[i].y * scale + offsetY);
    }
    ctx.stroke();
}

function generateDragon(depth) {
    dragonPoints = [{ x: 0, y: 0 }, { x: 1, y: 0 }];
    
    for (let d = 0; d < depth; d++) {
        const newPoints = [dragonPoints[0]];
        
        for (let i = 0; i < dragonPoints.length - 1; i++) {
            const p1 = dragonPoints[i];
            const p2 = dragonPoints[i + 1];
            
            const mx = (p1.x + p2.x) / 2;
            const my = (p1.y + p2.y) / 2;
            const dx = p2.x - p1.x;
            const dy = p2.y - p1.y;
            
            const dir = i % 2 === 0 ? 1 : -1;
            const nx = mx + dir * dy / 2;
            const ny = my - dir * dx / 2;
            
            newPoints.push({ x: nx, y: ny });
            newPoints.push(p2);
        }
        
        dragonPoints = newPoints;
    }
}

function getDragonBounds() {
    let minX = Infinity, maxX = -Infinity;
    let minY = Infinity, maxY = -Infinity;
    
    dragonPoints.forEach(p => {
        minX = Math.min(minX, p.x);
        maxX = Math.max(maxX, p.x);
        minY = Math.min(minY, p.y);
        maxY = Math.max(maxY, p.y);
    });
    
    return { minX, maxX, minY, maxY };
}

async function animateDragon() {
    for (let d = 0; d <= state.depth; d++) {
        await checkPause();
        pushStack(`ç»˜åˆ¶æ·±åº¦ ${d}`);
        
        ctx.fillStyle = '#1a0a2e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        drawMagicBackground();
        
        generateDragon(d);
        
        if (dragonPoints.length >= 2) {
            const bounds = getDragonBounds();
            const scale = Math.min(
                canvas.width * 0.8 / Math.max(1, bounds.maxX - bounds.minX),
                canvas.height * 0.8 / Math.max(1, bounds.maxY - bounds.minY)
            );
            const offsetX = canvas.width / 2 - (bounds.minX + bounds.maxX) / 2 * scale;
            const offsetY = canvas.height / 2 - (bounds.minY + bounds.maxY) / 2 * scale;
            
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(dragonPoints[0].x * scale + offsetX, dragonPoints[0].y * scale + offsetY);
            
            for (let i = 1; i < dragonPoints.length; i++) {
                ctx.lineTo(dragonPoints[i].x * scale + offsetX, dragonPoints[i].y * scale + offsetY);
            }
            ctx.stroke();
        }
        
        await delay();
        await delay();
        popStack();
    }
}

// ========== æ§åˆ¶å‡½æ•° ==========
async function startAnimation() {
    if (state.running) return;
    
    state.running = true;
    state.paused = false;
    resetStats();
    
    document.getElementById('startBtn').disabled = true;
    document.getElementById('pauseBtn').disabled = false;
    document.getElementById('depthSlider').disabled = true;
    
    try {
        switch (state.mode) {
            case 'hanoi': await animateHanoi(); break;
            case 'koch': await animateKoch(); break;
            case 'sierpinski': await animateSierpinski(); break;
            case 'tree': await animateTree(); break;
            case 'carpet': await animateCarpet(); break;
            case 'dragon': await animateDragon(); break;
        }
        
        pushStack('âœ¨ å®Œæˆï¼');
    } catch (e) {
        if (e.message !== 'stopped') console.error(e);
    }
    
    state.running = false;
    document.getElementById('startBtn').disabled = false;
    document.getElementById('pauseBtn').disabled = true;
    document.getElementById('depthSlider').disabled = false;
}

function togglePause() {
    state.paused = !state.paused;
    document.getElementById('pauseBtn').textContent = state.paused ? 'â–¶ï¸' : 'â¸ï¸';
}

function stepAnimation() {
    if (!state.running) {
        startAnimation();
    }
    if (state.paused) {
        state.paused = false;
        setTimeout(() => { state.paused = true; }, 50);
    }
}

function resetAnimation() {
    state.running = false;
    state.paused = false;
    resetStats();
    
    if (state.mode === 'hanoi') initHanoi();
    
    document.getElementById('startBtn').disabled = false;
    document.getElementById('pauseBtn').disabled = true;
    document.getElementById('pauseBtn').textContent = 'â¸ï¸';
    document.getElementById('depthSlider').disabled = false;
    
    draw();
}

// å¯åŠ¨
init();
if (state.mode === 'hanoi') initHanoi();
</script>
</body>
</html>