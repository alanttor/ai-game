<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç –å—çƒŸå›±çˆ†ç ´æ¨¡æ‹Ÿå™¨</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
            color: #fff;
            font-family: 'Segoe UI', Arial, sans-serif;
            height: 100vh;
            overflow: hidden;
            position: relative;
        }

        canvas {
            display: block;
        }

        .control-panel {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 40, 0.9);
            padding: 20px;
            border-radius: 12px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            min-width: 220px;
        }

        .control-panel h2 {
            font-size: 1.1em;
            margin-bottom: 15px;
            color: #6af;
            text-shadow: 0 0 10px rgba(100, 170, 255, 0.5);
        }

        .btn {
            width: 100%;
            padding: 12px 20px;
            margin-bottom: 10px;
            border: none;
            border-radius: 8px;
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }

        .btn-explode {
            background: linear-gradient(135deg, #ff4444, #cc2222);
            color: white;
            box-shadow: 0 4px 15px rgba(255, 68, 68, 0.4);
        }

        .btn-explode:hover {
            background: linear-gradient(135deg, #ff6666, #dd3333);
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(255, 68, 68, 0.6);
        }

        .btn-reset {
            background: linear-gradient(135deg, #44aa44, #228822);
            color: white;
            box-shadow: 0 4px 15px rgba(68, 170, 68, 0.4);
        }

        .btn-reset:hover {
            background: linear-gradient(135deg, #55bb55, #339933);
            transform: translateY(-2px);
        }

        .controls-info {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid rgba(100, 150, 255, 0.2);
            font-size: 0.8em;
            color: #888;
            line-height: 1.6;
        }

        .controls-info strong {
            color: #6af;
        }

        .info-panel {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(20, 20, 40, 0.9);
            padding: 15px 20px;
            border-radius: 10px;
            border: 1px solid rgba(100, 150, 255, 0.3);
            font-size: 0.9em;
        }

        .info-panel div {
            margin: 5px 0;
        }

        .info-panel span {
            color: #6af;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div class="control-panel">
        <h2>ğŸ—ï¸ çˆ†ç ´æ§åˆ¶é¢æ¿</h2>
        <button class="btn btn-explode" id="btnExplode">ğŸ’¥ å¼•çˆ†æ¨¡æ‹Ÿ</button>
        <button class="btn btn-reset" id="btnReset">ğŸ”„ é‡ç½®åœºæ™¯</button>
        <div class="controls-info">
            <strong>è§†è§’æ§åˆ¶ï¼š</strong><br>
            é¼ æ ‡å·¦é”®ï¼šæ—‹è½¬è§†è§’<br>
            é¼ æ ‡å³é”®ï¼šç§»åŠ¨ä½ç½®<br>
            æ»šè½®ï¼šç¼©æ”¾è§†è§’
        </div>
    </div>

    <div class="info-panel">
        <div>ç‰©ç†å¯¹è±¡æ•°é‡ï¼š<span id="objectCount">0</span></div>
        <div>æ¨¡æ‹ŸçŠ¶æ€ï¼š<span id="simStatus">ç­‰å¾…å¼•çˆ†</span></div>
    </div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');

        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        });

        // 3Dç›¸æœºå‚æ•°
        let camera = {
            rotX: 0.4,
            rotY: 0.5,
            distance: 800,
            panX: 0,
            panY: 50
        };

        // ç‰©ç†å‚æ•°
        const GRAVITY = 0.5;
        const FRICTION = 0.98;
        const BOUNCE = 0.3;
        const GROUND_Y = 150;

        // ç –å—æ•°ç»„
        let bricks = [];
        let isExploded = false;
        let simulating = false;

        // ç –å—ç±»
        class Brick {
            constructor(x, y, z, w, h, d, color) {
                this.x = x; this.y = y; this.z = z;
                this.w = w; this.h = h; this.d = d;
                this.vx = 0; this.vy = 0; this.vz = 0;
                this.rotX = 0; this.rotY = 0; this.rotZ = 0;
                this.vRotX = 0; this.vRotY = 0; this.vRotZ = 0;
                this.color = color;
                this.isStatic = true;
                this.grounded = false;
            }

            applyExplosion(cx, cy, cz, force) {
                this.isStatic = false;
                const dx = this.x - cx;
                const dy = this.y - cy;
                const dz = this.z - cz;
                const dist = Math.sqrt(dx*dx + dy*dy + dz*dz) + 1;
                const f = force / dist;
                this.vx = (dx / dist) * f * (0.5 + Math.random() * 0.5);
                this.vy = (dy / dist) * f * (0.3 + Math.random() * 0.4) - 5;
                this.vz = (dz / dist) * f * (0.5 + Math.random() * 0.5);
                this.vRotX = (Math.random() - 0.5) * 0.3;
                this.vRotY = (Math.random() - 0.5) * 0.3;
                this.vRotZ = (Math.random() - 0.5) * 0.3;
            }

            update() {
                if (this.isStatic) return;

                this.vy += GRAVITY;
                this.vx *= FRICTION;
                this.vz *= FRICTION;

                this.x += this.vx;
                this.y += this.vy;
                this.z += this.vz;

                this.rotX += this.vRotX;
                this.rotY += this.vRotY;
                this.rotZ += this.vRotZ;

                // åœ°é¢ç¢°æ’
                if (this.y > GROUND_Y - this.h/2) {
                    this.y = GROUND_Y - this.h/2;
                    this.vy *= -BOUNCE;
                    this.vx *= 0.8;
                    this.vz *= 0.8;
                    this.vRotX *= 0.7;
                    this.vRotY *= 0.7;
                    this.vRotZ *= 0.7;
                    
                    if (Math.abs(this.vy) < 0.5) {
                        this.vy = 0;
                        this.grounded = true;
                    }
                }

                // åœæ­¢æ¡ä»¶
                if (this.grounded && Math.abs(this.vx) < 0.1 && Math.abs(this.vz) < 0.1) {
                    this.vx = 0; this.vz = 0;
                    this.vRotX *= 0.9;
                    this.vRotY *= 0.9;
                    this.vRotZ *= 0.9;
                }
            }
        }

        // 3DæŠ•å½±
        function project(x, y, z) {
            // æ—‹è½¬
            let cosY = Math.cos(camera.rotY), sinY = Math.sin(camera.rotY);
            let cosX = Math.cos(camera.rotX), sinX = Math.sin(camera.rotX);

            let x1 = x * cosY - z * sinY;
            let z1 = x * sinY + z * cosY;
            let y1 = y * cosX - z1 * sinX;
            let z2 = y * sinX + z1 * cosX;

            z2 += camera.distance;
            if (z2 < 1) z2 = 1;

            const scale = 500 / z2;
            return {
                x: canvas.width/2 + x1 * scale + camera.panX,
                y: canvas.height/2 + y1 * scale + camera.panY,
                z: z2,
                scale: scale
            };
        }

        // ç»˜åˆ¶3Dç –å—
        function drawBrick(brick) {
            const hw = brick.w/2, hh = brick.h/2, hd = brick.d/2;
            
            // 8ä¸ªé¡¶ç‚¹ï¼ˆæœ¬åœ°åæ ‡ï¼‰
            let vertices = [
                [-hw, -hh, -hd], [hw, -hh, -hd], [hw, hh, -hd], [-hw, hh, -hd],
                [-hw, -hh, hd], [hw, -hh, hd], [hw, hh, hd], [-hw, hh, hd]
            ];

            // åº”ç”¨æ—‹è½¬
            const cosX = Math.cos(brick.rotX), sinX = Math.sin(brick.rotX);
            const cosY = Math.cos(brick.rotY), sinY = Math.sin(brick.rotY);
            const cosZ = Math.cos(brick.rotZ), sinZ = Math.sin(brick.rotZ);

            vertices = vertices.map(v => {
                let [x, y, z] = v;
                // ç»•Xè½´
                let y1 = y * cosX - z * sinX;
                let z1 = y * sinX + z * cosX;
                // ç»•Yè½´
                let x2 = x * cosY + z1 * sinY;
                let z2 = -x * sinY + z1 * cosY;
                // ç»•Zè½´
                let x3 = x2 * cosZ - y1 * sinZ;
                let y3 = x2 * sinZ + y1 * cosZ;
                return [x3 + brick.x, y3 + brick.y, z2 + brick.z];
            });

            // æŠ•å½±
            const projected = vertices.map(v => project(v[0], v[1], v[2]));

            // é¢å®šä¹‰ [é¡¶ç‚¹ç´¢å¼•, é¢œè‰²è°ƒæ•´]
            const faces = [
                [[0,1,2,3], 0.7],   // å‰
                [[5,4,7,6], 0.7],   // å
                [[4,0,3,7], 0.5],   // å·¦
                [[1,5,6,2], 0.9],   // å³
                [[4,5,1,0], 0.6],   // ä¸Š
                [[3,2,6,7], 1.0]    // ä¸‹
            ];

            // æŒ‰æ·±åº¦æ’åºé¢
            const sortedFaces = faces.map((f, i) => {
                const avgZ = f[0].reduce((sum, vi) => sum + projected[vi].z, 0) / 4;
                return { face: f, avgZ, index: i };
            }).sort((a, b) => b.avgZ - a.avgZ);

            // ç»˜åˆ¶é¢
            sortedFaces.forEach(({ face }) => {
                const [indices, brightness] = face;
                const pts = indices.map(i => projected[i]);

                // èƒŒé¢å‰”é™¤
                const v1x = pts[1].x - pts[0].x, v1y = pts[1].y - pts[0].y;
                const v2x = pts[2].x - pts[0].x, v2y = pts[2].y - pts[0].y;
                if (v1x * v2y - v1y * v2x > 0) return;

                ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
                pts.forEach(p => ctx.lineTo(p.x, p.y));
                ctx.closePath();

                // é¢œè‰²
                const r = parseInt(brick.color.slice(1,3), 16);
                const g = parseInt(brick.color.slice(3,5), 16);
                const b = parseInt(brick.color.slice(5,7), 16);
                ctx.fillStyle = `rgb(${Math.floor(r*brightness)},${Math.floor(g*brightness)},${Math.floor(b*brightness)})`;
                ctx.fill();
                ctx.strokeStyle = 'rgba(0,0,0,0.3)';
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            return projected[0].z; // è¿”å›æ·±åº¦ç”¨äºæ’åº
        }

        // ç»˜åˆ¶åœ°é¢
        function drawGround() {
            const size = 400;
            const y = GROUND_Y;
            const corners = [
                project(-size, y, -size),
                project(size, y, -size),
                project(size, y, size),
                project(-size, y, size)
            ];

            ctx.beginPath();
            ctx.moveTo(corners[0].x, corners[0].y);
            corners.forEach(c => ctx.lineTo(c.x, c.y));
            ctx.closePath();
            ctx.fillStyle = '#2a2a3a';
            ctx.fill();
            ctx.strokeStyle = '#3a3a5a';
            ctx.lineWidth = 2;
            ctx.stroke();

            // ç½‘æ ¼çº¿
            ctx.strokeStyle = 'rgba(100, 150, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = -size; i <= size; i += 50) {
                const p1 = project(i, y, -size);
                const p2 = project(i, y, size);
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();

                const p3 = project(-size, y, i);
                const p4 = project(size, y, i);
                ctx.beginPath();
                ctx.moveTo(p3.x, p3.y);
                ctx.lineTo(p4.x, p4.y);
                ctx.stroke();
            }
        }

        // åˆ›å»ºçƒŸå›±
        function createChimney() {
            bricks = [];
            isExploded = false;
            simulating = false;

            const brickW = 30, brickH = 15, brickD = 15;
            const layers = 15;
            const radius = 50;

            for (let layer = 0; layer < layers; layer++) {
                const y = GROUND_Y - brickH/2 - layer * brickH;
                const bricksInLayer = 12;
                const offset = (layer % 2) * (Math.PI / bricksInLayer);

                for (let i = 0; i < bricksInLayer; i++) {
                    const angle = (i / bricksInLayer) * Math.PI * 2 + offset;
                    const x = Math.cos(angle) * radius;
                    const z = Math.sin(angle) * radius;

                    // ç –å—é¢œè‰²å˜åŒ–
                    const shade = 0.7 + Math.random() * 0.3;
                    const r = Math.floor(180 * shade);
                    const g = Math.floor(80 * shade);
                    const b = Math.floor(60 * shade);
                    const color = `#${r.toString(16).padStart(2,'0')}${g.toString(16).padStart(2,'0')}${b.toString(16).padStart(2,'0')}`;

                    const brick = new Brick(x, y, z, brickW, brickH, brickD, color);
                    brick.rotY = angle;
                    bricks.push(brick);
                }
            }

            updateInfo();
        }

        // å¼•çˆ†
        function explode() {
            if (isExploded) return;
            isExploded = true;
            simulating = true;
            document.getElementById('simStatus').textContent = 'æ¨¡æ‹Ÿä¸­...';

            // çˆ†ç‚¸ä¸­å¿ƒåœ¨çƒŸå›±åº•éƒ¨
            const cx = 0, cy = GROUND_Y - 50, cz = 0;
            bricks.forEach(brick => {
                brick.applyExplosion(cx, cy, cz, 150);
            });
        }

        // æ›´æ–°ä¿¡æ¯
        function updateInfo() {
            document.getElementById('objectCount').textContent = bricks.length;
        }

        // æ£€æŸ¥æ¨¡æ‹Ÿæ˜¯å¦å®Œæˆ
        function checkSimulationComplete() {
            if (!simulating) return;
            
            const allStopped = bricks.every(b => 
                b.grounded && Math.abs(b.vx) < 0.1 && Math.abs(b.vy) < 0.5 && Math.abs(b.vz) < 0.1
            );

            if (allStopped) {
                simulating = false;
                document.getElementById('simStatus').textContent = 'æ¨¡æ‹Ÿå®Œæˆ';
            }
        }

        // ä¸»å¾ªç¯
        function animate() {
            ctx.fillStyle = '#0f0f1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ç»˜åˆ¶åœ°é¢
            drawGround();

            // æ›´æ–°ç‰©ç†
            bricks.forEach(brick => brick.update());

            // æŒ‰æ·±åº¦æ’åºç –å—
            const sortedBricks = bricks.map((brick, i) => {
                const p = project(brick.x, brick.y, brick.z);
                return { brick, depth: p.z };
            }).sort((a, b) => b.depth - a.depth);

            // ç»˜åˆ¶ç –å—
            sortedBricks.forEach(({ brick }) => drawBrick(brick));

            checkSimulationComplete();
            requestAnimationFrame(animate);
        }

        // é¼ æ ‡æ§åˆ¶
        let isDragging = false;
        let isRightDrag = false;
        let lastX, lastY;

        canvas.addEventListener('mousedown', (e) => {
            isDragging = true;
            isRightDrag = e.button === 2;
            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!isDragging) return;
            const dx = e.clientX - lastX;
            const dy = e.clientY - lastY;

            if (isRightDrag) {
                camera.panX += dx;
                camera.panY += dy;
            } else {
                camera.rotY += dx * 0.01;
                camera.rotX += dy * 0.01;
                camera.rotX = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotX));
            }

            lastX = e.clientX;
            lastY = e.clientY;
        });

        canvas.addEventListener('mouseup', () => isDragging = false);
        canvas.addEventListener('mouseleave', () => isDragging = false);

        canvas.addEventListener('wheel', (e) => {
            e.preventDefault();
            camera.distance += e.deltaY * 0.5;
            camera.distance = Math.max(300, Math.min(2000, camera.distance));
        });

        canvas.addEventListener('contextmenu', (e) => e.preventDefault());

        // æŒ‰é’®äº‹ä»¶
        document.getElementById('btnExplode').addEventListener('click', explode);
        document.getElementById('btnReset').addEventListener('click', () => {
            createChimney();
            document.getElementById('simStatus').textContent = 'ç­‰å¾…å¼•çˆ†';
        });

        // åˆå§‹åŒ–
        createChimney();
        animate();
    </script>
</body>
</html>