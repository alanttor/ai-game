<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤ä»£å†œä¸šæ°´åˆ©å·¥ç¨‹æ¨¡æ‹Ÿå™¨</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸŒ¾</text></svg>">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'SimSun', serif;
            background: #1a2a1a;
            min-height: 100vh;
            color: #c4d4a8;
            overflow: hidden;
        }
        .container { display: flex; flex-direction: column; height: 100vh; }
        .main-area { display: flex; flex: 1; }
        .map-area {
            flex: 1;
            position: relative;
            background: #2a3a2a;
        }
        #mapCanvas { display: block; width: 100%; height: 100%; }
        .side-panel {
            width: 280px;
            background: rgba(20,30,20,0.95);
            border-left: 1px solid #3a4a3a;
            padding: 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .bottom-panel {
            height: 80px;
            background: rgba(20,30,20,0.95);
            border-top: 1px solid #3a4a3a;
            padding: 10px;
            display: flex;
            gap: 10px;
            align-items: center;
        }
        .panel-title {
            font-size: 0.9em;
            color: #8ac060;
            border-bottom: 1px solid #3a4a3a;
            padding-bottom: 5px;
            margin-bottom: 5px;
        }
        .panel-section {
            background: rgba(255,255,255,0.03);
            border-radius: 6px;
            padding: 10px;
        }
        .tool-btn {
            width: 60px;
            height: 60px;
            border: 2px solid #3a4a3a;
            border-radius: 8px;
            background: rgba(255,255,255,0.05);
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            color: #c4d4a8;
        }
        .tool-btn:hover { border-color: #8ac060; }
        .tool-btn.active { border-color: #8ac060; background: rgba(138,192,96,0.2); }
        .tool-icon { font-size: 1.5em; }
        .tool-name { font-size: 0.65em; margin-top: 3px; }
</style>
</head>
<body>
<div class="container">
    <div class="main-area">
        <div class="map-area">
            <canvas id="mapCanvas"></canvas>
        </div>
        <div class="side-panel" id="sidePanel"></div>
    </div>
    <div class="bottom-panel" id="bottomPanel"></div>
</div>
<script>
let canvas, ctx;
const GRID_SIZE = 40;
let gridW, gridH;
let grid = [];
let selectedTool = null;
let year = 0;
let season = 0; // 0-3: æ˜¥å¤ç§‹å†¬
let paused = false;

// æ–‡æ˜é…ç½®
const civilizations = {
    mesopotamia: { name: 'ç¾ç´¢ä¸è¾¾ç±³äºš', river: 'å¹¼å‘æ‹‰åº•æ²³', challenge: 'ç›ç¢±åŒ–' },
    egypt: { name: 'å¤åŸƒåŠ', river: 'å°¼ç½—æ²³', challenge: 'æ´ªæ°´å‘¨æœŸ' },
    indus: { name: 'å°åº¦æ²³è°·', river: 'å°åº¦æ²³', challenge: 'å­£é£å˜åŒ–' },
    china: { name: 'å¤ä»£ä¸­å›½', river: 'é»„æ²³', challenge: 'æ°´æ‚£æ²»ç†' }
};

let currentCiv = 'egypt';

// ç»Ÿè®¡æ•°æ®
let stats = {
    population: 1000,
    food: 500,
    water: 100,
    happiness: 50
};

// å·¥å…·
const tools = [
    { id: 'canal', name: 'æ°´æ¸ ', icon: 'ğŸŒŠ', cost: 50 },
    { id: 'dam', name: 'æ°´å', icon: 'ğŸ§±', cost: 100 },
    { id: 'farm', name: 'å†œç”°', icon: 'ğŸŒ¾', cost: 30 },
    { id: 'village', name: 'æ‘åº„', icon: 'ğŸ˜ï¸', cost: 80 },
    { id: 'well', name: 'æ°´äº•', icon: 'â›²', cost: 40 }
];

// æ ¼å­ç±»å‹
const CELL_TYPES = {
    empty: { color: '#c4b090', name: 'è’åœ°' },
    river: { color: '#4a90c4', name: 'æ²³æµ' },
    canal: { color: '#6ab0d4', name: 'æ°´æ¸ ' },
    dam: { color: '#8a7a60', name: 'æ°´å' },
    farm: { color: '#8ac060', name: 'å†œç”°' },
    village: { color: '#d4a060', name: 'æ‘åº„' },
    well: { color: '#60a0c4', name: 'æ°´äº•' },
    flooded: { color: '#3a70a4', name: 'æ´ªæ°´' },
    irrigated: { color: '#6ac070', name: 'çŒæº‰ç”°' }
};

function init() {
    canvas = document.getElementById('mapCanvas');
    ctx = canvas.getContext('2d');
    resizeCanvas();
    initGrid();
    renderSidePanel();
    renderBottomPanel();
    
    canvas.addEventListener('click', handleClick);
    canvas.addEventListener('mousemove', handleMove);
    window.addEventListener('resize', resizeCanvas);
    
    setInterval(simulate, 1000);
    animate();
}

function resizeCanvas() {
    canvas.width = canvas.parentElement.clientWidth;
    canvas.height = canvas.parentElement.clientHeight;
    gridW = Math.floor(canvas.width / GRID_SIZE);
    gridH = Math.floor(canvas.height / GRID_SIZE);
}

function initGrid() {
    grid = [];
    for (let y = 0; y < gridH; y++) {
        grid[y] = [];
        for (let x = 0; x < gridW; x++) {
            grid[y][x] = {
                type: 'empty',
                water: 0,
                fertility: 0.3 + Math.random() * 0.3
            };
        }
    }
    
    // æ·»åŠ æ²³æµ
    const riverY = Math.floor(gridH / 2);
    for (let x = 0; x < gridW; x++) {
        const y = riverY + Math.floor(Math.sin(x * 0.3) * 2);
        if (y >= 0 && y < gridH) {
            grid[y][x].type = 'river';
            grid[y][x].water = 100;
            // æ²³å²¸è‚¥æ²ƒ
            if (y > 0) grid[y-1][x].fertility = 0.8;
            if (y < gridH - 1) grid[y+1][x].fertility = 0.8;
        }
    }
}

function renderSidePanel() {
    const panel = document.getElementById('sidePanel');
    const civ = civilizations[currentCiv];
    const seasonNames = ['ğŸŒ¸ æ˜¥', 'â˜€ï¸ å¤', 'ğŸ‚ ç§‹', 'â„ï¸ å†¬'];
    
    panel.innerHTML = `
        <style>
            .slider-group { margin-bottom: 8px; }
            .slider-label { display: flex; justify-content: space-between; font-size: 0.75em; color: #8a9a7a; margin-bottom: 3px; }
            input[type="range"] { width: 100%; height: 4px; border-radius: 2px; background: #3a4a3a; -webkit-appearance: none; }
            input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 12px; height: 12px; border-radius: 50%; background: #8ac060; cursor: pointer; }
            .btn { padding: 6px 10px; border: none; border-radius: 4px; cursor: pointer; font-size: 0.8em; margin: 2px; }
            .btn-primary { background: #3a5a3a; color: #c4d4a8; border: 1px solid #4a6a4a; }
            .btn-secondary { background: rgba(255,255,255,0.05); color: #8a9a7a; }
            .stat-bar { height: 8px; background: #2a3a2a; border-radius: 4px; margin-top: 3px; overflow: hidden; }
            .stat-fill { height: 100%; border-radius: 4px; transition: width 0.3s; }
            .civ-btn { display: block; width: 100%; text-align: left; padding: 8px; margin: 3px 0; font-size: 0.8em; }
        </style>
        
        <div style="text-align:center;margin-bottom:8px;">
            <h2 style="color:#8ac060;font-size:1.1em;">ğŸŒ¾ ${civ.name}</h2>
            <p style="color:#5a6a5a;font-size:0.7em;">${civ.river} æµåŸŸ</p>
        </div>
        
        <div class="panel-section">
            <div class="panel-title">ğŸ“… æ—¶é—´</div>
            <div style="text-align:center;font-size:1.2em;color:#8ac060;">
                ç¬¬ ${year} å¹´ ${seasonNames[season]}
            </div>
            <div style="display:flex;gap:4px;margin-top:8px;">
                <button class="btn ${paused ? 'btn-primary' : 'btn-secondary'}" onclick="togglePause()">
                    ${paused ? 'â–¶ï¸' : 'â¸ï¸'}
                </button>
                <button class="btn btn-secondary" onclick="initGrid(); renderSidePanel();">ğŸ”„</button>
            </div>
        </div>
        
        <div class="panel-section">
            <div class="panel-title">ğŸ“Š èµ„æºçŠ¶æ€</div>
            <div class="slider-group">
                <div class="slider-label"><span>ğŸ‘¥ äººå£</span><span>${stats.population.toLocaleString()}</span></div>
                <div class="stat-bar"><div class="stat-fill" style="width:${Math.min(100, stats.population/100)}%;background:#d4a060;"></div></div>
            </div>
            <div class="slider-group">
                <div class="slider-label"><span>ğŸŒ¾ ç²®é£Ÿ</span><span>${stats.food.toFixed(0)}</span></div>
                <div class="stat-bar"><div class="stat-fill" style="width:${Math.min(100, stats.food/10)}%;background:#8ac060;"></div></div>
            </div>
            <div class="slider-group">
                <div class="slider-label"><span>ğŸ’§ æ°´èµ„æº</span><span>${stats.water.toFixed(0)}%</span></div>
                <div class="stat-bar"><div class="stat-fill" style="width:${stats.water}%;background:#4a90c4;"></div></div>
            </div>
            <div class="slider-group">
                <div class="slider-label"><span>ğŸ˜Š å¹¸ç¦åº¦</span><span>${stats.happiness.toFixed(0)}%</span></div>
                <div class="stat-bar"><div class="stat-fill" style="width:${stats.happiness}%;background:#c4a060;"></div></div>
            </div>
        </div>
        
        <div class="panel-section">
            <div class="panel-title">ğŸ›ï¸ é€‰æ‹©æ–‡æ˜</div>
            ${Object.entries(civilizations).map(([k, c]) => `
                <button class="btn civ-btn ${currentCiv === k ? 'btn-primary' : 'btn-secondary'}" 
                        onclick="setCiv('${k}')">${c.name}</button>
            `).join('')}
        </div>
        
        <div class="panel-section">
            <div class="panel-title">âš ï¸ å½“å‰æŒ‘æˆ˜</div>
            <div style="font-size:0.8em;color:#c4a060;padding:8px;background:rgba(196,160,96,0.1);border-radius:4px;">
                ${civ.challenge}
            </div>
        </div>
        
        <div class="panel-section">
            <div class="panel-title">ğŸ’¡ è¯´æ˜</div>
            <div style="font-size:0.7em;color:#5a6a5a;line-height:1.4;">
                ç‚¹å‡»ä¸‹æ–¹å·¥å…·ï¼Œç„¶ååœ¨åœ°å›¾ä¸Šæ”¾ç½®ã€‚<br>
                <b>æ°´æ¸ </b>ï¼šå¼•æ°´çŒæº‰å†œç”°<br>
                <b>æ°´å</b>ï¼šæ§åˆ¶æ´ªæ°´<br>
                <b>å†œç”°</b>ï¼šç”Ÿäº§ç²®é£Ÿ<br>
                é è¿‘æ°´æºçš„å†œç”°äº§é‡æ›´é«˜ã€‚
            </div>
        </div>
    `;
}

function renderBottomPanel() {
    const panel = document.getElementById('bottomPanel');
    panel.innerHTML = tools.map(t => `
        <div class="tool-btn ${selectedTool === t.id ? 'active' : ''}" onclick="selectTool('${t.id}')">
            <span class="tool-icon">${t.icon}</span>
            <span class="tool-name">${t.name}</span>
        </div>
    `).join('') + `
        <div style="flex:1;"></div>
        <div style="font-size:0.8em;color:#8a9a7a;">
            ğŸ’° èµ„æº: ${stats.food.toFixed(0)} | é€‰æ‹©å·¥å…·åç‚¹å‡»åœ°å›¾æ”¾ç½®
        </div>
    `;
}

function selectTool(id) {
    selectedTool = selectedTool === id ? null : id;
    renderBottomPanel();
}

function setCiv(civ) {
    currentCiv = civ;
    initGrid();
    stats = { population: 1000, food: 500, water: 100, happiness: 50 };
    year = 0;
    renderSidePanel();
}

function togglePause() {
    paused = !paused;
    renderSidePanel();
}

function handleClick(e) {
    if (!selectedTool) return;
    
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / GRID_SIZE);
    const y = Math.floor((e.clientY - rect.top) / GRID_SIZE);
    
    if (x < 0 || x >= gridW || y < 0 || y >= gridH) return;
    
    const cell = grid[y][x];
    const tool = tools.find(t => t.id === selectedTool);
    
    if (cell.type === 'river' || cell.type === 'flooded') return;
    if (stats.food < tool.cost) return;
    
    stats.food -= tool.cost;
    cell.type = selectedTool;
    
    renderSidePanel();
    renderBottomPanel();
}

function handleMove(e) {
    const rect = canvas.getBoundingClientRect();
    const x = Math.floor((e.clientX - rect.left) / GRID_SIZE);
    const y = Math.floor((e.clientY - rect.top) / GRID_SIZE);
    
    canvas.style.cursor = selectedTool && x >= 0 && x < gridW && y >= 0 && y < gridH ? 'pointer' : 'default';
}

function simulate() {
    if (paused) return;
    
    // å­£èŠ‚å˜åŒ–
    season = (season + 1) % 4;
    if (season === 0) year++;
    
    // æ°´èµ„æºæ¨¡æ‹Ÿ
    simulateWater();
    
    // å†œä¸šç”Ÿäº§
    simulateFarming();
    
    // äººå£å˜åŒ–
    simulatePopulation();
    
    renderSidePanel();
    renderBottomPanel();
}

function simulateWater() {
    // å­£èŠ‚æ€§æ°´é‡å˜åŒ–
    const seasonWater = [0.8, 0.6, 0.7, 0.5][season]; // æ˜¥å¤ç§‹å†¬
    
    // æ´ªæ°´äº‹ä»¶ï¼ˆå¤å­£ï¼‰
    const floodChance = season === 1 ? 0.3 : 0.05;
    
    for (let y = 0; y < gridH; y++) {
        for (let x = 0; x < gridW; x++) {
            const cell = grid[y][x];
            
            // æ²³æµæ°´é‡
            if (cell.type === 'river') {
                cell.water = 100 * seasonWater;
                
                // æ´ªæ°´æ‰©æ•£
                if (Math.random() < floodChance && currentCiv === 'egypt') {
                    spreadFlood(x, y);
                }
            }
            
            // æ°´æ¸ ä¼ æ°´
            if (cell.type === 'canal') {
                const nearRiver = hasNearby(x, y, 'river') || hasNearby(x, y, 'canal');
                cell.water = nearRiver ? 80 * seasonWater : Math.max(0, cell.water - 10);
            }
            
            // æ°´äº•
            if (cell.type === 'well') {
                cell.water = 50;
            }
            
            // å†œç”°çŒæº‰
            if (cell.type === 'farm') {
                const nearWater = hasNearby(x, y, 'river') || hasNearby(x, y, 'canal') || hasNearby(x, y, 'well');
                cell.water = nearWater ? 60 : 10;
                cell.type = nearWater ? 'irrigated' : 'farm';
            }
            
            if (cell.type === 'irrigated') {
                const nearWater = hasNearby(x, y, 'river') || hasNearby(x, y, 'canal') || hasNearby(x, y, 'well');
                if (!nearWater) cell.type = 'farm';
            }
        }
    }
    
    // è®¡ç®—æ€»æ°´èµ„æº
    let totalWater = 0, waterCells = 0;
    for (let y = 0; y < gridH; y++) {
        for (let x = 0; x < gridW; x++) {
            if (grid[y][x].water > 0) {
                totalWater += grid[y][x].water;
                waterCells++;
            }
        }
    }
    stats.water = waterCells > 0 ? totalWater / waterCells : 0;
}

function spreadFlood(rx, ry) {
    for (let dy = -2; dy <= 2; dy++) {
        for (let dx = -2; dx <= 2; dx++) {
            const x = rx + dx;
            const y = ry + dy;
            if (x >= 0 && x < gridW && y >= 0 && y < gridH) {
                const cell = grid[y][x];
                if (cell.type === 'empty' || cell.type === 'farm') {
                    if (Math.random() < 0.3) {
                        cell.type = 'flooded';
                        cell.water = 100;
                        cell.fertility = Math.min(1, cell.fertility + 0.1); // æ´ªæ°´å¸¦æ¥è‚¥æ²ƒåœŸå£¤
                    }
                }
            }
        }
    }
}

function hasNearby(x, y, type) {
    for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
            const nx = x + dx;
            const ny = y + dy;
            if (nx >= 0 && nx < gridW && ny >= 0 && ny < gridH) {
                if (grid[ny][nx].type === type) return true;
            }
        }
    }
    return false;
}

function simulateFarming() {
    let foodProduction = 0;
    
    for (let y = 0; y < gridH; y++) {
        for (let x = 0; x < gridW; x++) {
            const cell = grid[y][x];
            
            // æ´ªæ°´é€€å»
            if (cell.type === 'flooded') {
                cell.water -= 20;
                if (cell.water <= 0) {
                    cell.type = 'empty';
                    cell.water = 0;
                }
            }
            
            // å†œç”°äº§å‡º
            if (cell.type === 'farm' || cell.type === 'irrigated') {
                const waterBonus = cell.type === 'irrigated' ? 2 : 0.5;
                const seasonBonus = [1, 1.5, 1.2, 0.3][season]; // æ˜¥å¤ç§‹å†¬
                foodProduction += cell.fertility * waterBonus * seasonBonus * 5;
            }
        }
    }
    
    // äººå£æ¶ˆè€—ç²®é£Ÿ
    const consumption = stats.population * 0.01;
    stats.food = Math.max(0, stats.food + foodProduction - consumption);
}

function simulatePopulation() {
    // äººå£å¢é•¿/å‡å°‘
    const foodPerCapita = stats.food / stats.population;
    
    if (foodPerCapita > 0.5) {
        stats.population *= 1.01; // å¢é•¿
        stats.happiness = Math.min(100, stats.happiness + 1);
    } else if (foodPerCapita < 0.2) {
        stats.population *= 0.98; // é¥¥è’
        stats.happiness = Math.max(0, stats.happiness - 5);
    }
    
    stats.population = Math.max(100, stats.population);
}

function draw() {
    ctx.fillStyle = '#c4b090';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // ç»˜åˆ¶ç½‘æ ¼
    for (let y = 0; y < gridH; y++) {
        for (let x = 0; x < gridW; x++) {
            const cell = grid[y][x];
            const px = x * GRID_SIZE;
            const py = y * GRID_SIZE;
            
            // åŸºç¡€é¢œè‰²
            ctx.fillStyle = CELL_TYPES[cell.type]?.color || '#c4b090';
            ctx.fillRect(px, py, GRID_SIZE - 1, GRID_SIZE - 1);
            
            // æ°´é‡æŒ‡ç¤º
            if (cell.water > 0 && cell.type !== 'river') {
                ctx.fillStyle = `rgba(74, 144, 196, ${cell.water / 200})`;
                ctx.fillRect(px, py, GRID_SIZE - 1, GRID_SIZE - 1);
            }
            
            // è‚¥æ²ƒåº¦æŒ‡ç¤º
            if (cell.type === 'empty' && cell.fertility > 0.5) {
                ctx.fillStyle = `rgba(138, 192, 96, ${(cell.fertility - 0.5) * 0.5})`;
                ctx.fillRect(px, py, GRID_SIZE - 1, GRID_SIZE - 1);
            }
            
            // å›¾æ ‡
            if (cell.type === 'village') {
                ctx.font = '20px Arial';
                ctx.fillText('ğŸ˜ï¸', px + 8, py + 28);
            } else if (cell.type === 'well') {
                ctx.font = '18px Arial';
                ctx.fillText('â›²', px + 10, py + 26);
            } else if (cell.type === 'dam') {
                ctx.font = '18px Arial';
                ctx.fillText('ğŸ§±', px + 10, py + 26);
            }
        }
    }
    
    // ç»˜åˆ¶æ²³æµåŠ¨ç”»
    drawRiverAnimation();
}

function drawRiverAnimation() {
    const time = Date.now() / 1000;
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
    ctx.lineWidth = 2;
    
    for (let y = 0; y < gridH; y++) {
        for (let x = 0; x < gridW; x++) {
            if (grid[y][x].type === 'river') {
                const px = x * GRID_SIZE + GRID_SIZE / 2;
                const py = y * GRID_SIZE + GRID_SIZE / 2;
                const offset = Math.sin(time * 2 + x * 0.5) * 3;
                
                ctx.beginPath();
                ctx.moveTo(px - 10, py + offset);
                ctx.lineTo(px + 10, py + offset);
                ctx.stroke();
            }
        }
    }
}

function animate() {
    draw();
    requestAnimationFrame(animate);
}

init();
</script>
</body>
</html>