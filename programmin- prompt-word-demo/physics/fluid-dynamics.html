<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ç²˜æ€§æµä½“æ¶¡æ—‹æ¼”åŒ–æ¨¡æ‹Ÿå™¨</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ’§</text></svg>">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #0a0a1a;
            min-height: 100vh;
            color: #fff;
            overflow: hidden;
        }
        .container { display: flex; height: 100vh; }
        .canvas-area {
            flex: 8;
            position: relative;
            background: #000;
        }
        #fluidCanvas { display: block; width: 100%; height: 100%; cursor: crosshair; }
        .control-panel {
            flex: 2;
            min-width: 240px;
            background: rgba(0,0,0,0.8);
            border-left: 1px solid #0af3;
            padding: 12px;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }
        .panel-title {
            font-size: 0.95em;
            color: #0af;
            border-bottom: 1px solid #0af3;
            padding-bottom: 6px;
            margin-bottom: 6px;
        }
        .panel-section {
            background: rgba(255,255,255,0.05);
            border-radius: 8px;
            padding: 10px;
        }
</style>
</head>
<body>
<div class="container">
    <div class="canvas-area">
        <canvas id="fluidCanvas"></canvas>
    </div>
    <div class="control-panel" id="controlPanel"></div>
</div>
<script>
// æµä½“æ¨¡æ‹Ÿå‚æ•°
const N = 128; // ç½‘æ ¼åˆ†è¾¨ç‡
const iter = 4; // è¿­ä»£æ¬¡æ•°
let canvas, ctx;
let dt = 0.1;
let visc = 0.0001;
let diff = 0.0001;

// æµä½“åœº
let u = new Float32Array((N + 2) * (N + 2)); // xé€Ÿåº¦
let v = new Float32Array((N + 2) * (N + 2)); // yé€Ÿåº¦
let u_prev = new Float32Array((N + 2) * (N + 2));
let v_prev = new Float32Array((N + 2) * (N + 2));
let dens = new Float32Array((N + 2) * (N + 2)); // å¯†åº¦/æŸ“æ–™
let dens_prev = new Float32Array((N + 2) * (N + 2));

// ç²’å­ç³»ç»Ÿ
let particles = [];
const MAX_PARTICLES = 3000;

// äº¤äº’çŠ¶æ€
let mouseDown = false;
let mouseX = 0, mouseY = 0;
let pmouseX = 0, pmouseY = 0;
let colorMode = 'velocity';
let showParticles = true;
let showVectors = false;

function IX(i, j) { return i + (N + 2) * j; }

// è¾¹ç•Œæ¡ä»¶
function set_bnd(b, x) {
    for (let i = 1; i <= N; i++) {
        x[IX(0, i)] = b === 1 ? -x[IX(1, i)] : x[IX(1, i)];
        x[IX(N + 1, i)] = b === 1 ? -x[IX(N, i)] : x[IX(N, i)];
        x[IX(i, 0)] = b === 2 ? -x[IX(i, 1)] : x[IX(i, 1)];
        x[IX(i, N + 1)] = b === 2 ? -x[IX(i, N)] : x[IX(i, N)];
    }
    x[IX(0, 0)] = 0.5 * (x[IX(1, 0)] + x[IX(0, 1)]);
    x[IX(0, N + 1)] = 0.5 * (x[IX(1, N + 1)] + x[IX(0, N)]);
    x[IX(N + 1, 0)] = 0.5 * (x[IX(N, 0)] + x[IX(N + 1, 1)]);
    x[IX(N + 1, N + 1)] = 0.5 * (x[IX(N, N + 1)] + x[IX(N + 1, N)]);
}

// æ‰©æ•£
function diffuse(b, x, x0, diff, dt) {
    const a = dt * diff * N * N;
    for (let k = 0; k < iter; k++) {
        for (let i = 1; i <= N; i++) {
            for (let j = 1; j <= N; j++) {
                x[IX(i, j)] = (x0[IX(i, j)] + a * (
                    x[IX(i - 1, j)] + x[IX(i + 1, j)] +
                    x[IX(i, j - 1)] + x[IX(i, j + 1)]
                )) / (1 + 4 * a);
            }
        }
        set_bnd(b, x);
    }
}

// å¹³æµ
function advect(b, d, d0, u, v, dt) {
    const dt0 = dt * N;
    for (let i = 1; i <= N; i++) {
        for (let j = 1; j <= N; j++) {
            let x = i - dt0 * u[IX(i, j)];
            let y = j - dt0 * v[IX(i, j)];
            
            if (x < 0.5) x = 0.5;
            if (x > N + 0.5) x = N + 0.5;
            const i0 = Math.floor(x);
            const i1 = i0 + 1;
            
            if (y < 0.5) y = 0.5;
            if (y > N + 0.5) y = N + 0.5;
            const j0 = Math.floor(y);
            const j1 = j0 + 1;
            
            const s1 = x - i0;
            const s0 = 1 - s1;
            const t1 = y - j0;
            const t0 = 1 - t1;
            
            d[IX(i, j)] = s0 * (t0 * d0[IX(i0, j0)] + t1 * d0[IX(i0, j1)]) +
                          s1 * (t0 * d0[IX(i1, j0)] + t1 * d0[IX(i1, j1)]);
        }
    }
    set_bnd(b, d);
}

// æŠ•å½±ï¼ˆä¿æŒä¸å¯å‹ç¼©æ€§ï¼‰
function project(u, v, p, div) {
    const h = 1.0 / N;
    
    for (let i = 1; i <= N; i++) {
        for (let j = 1; j <= N; j++) {
            div[IX(i, j)] = -0.5 * h * (
                u[IX(i + 1, j)] - u[IX(i - 1, j)] +
                v[IX(i, j + 1)] - v[IX(i, j - 1)]
            );
            p[IX(i, j)] = 0;
        }
    }
    set_bnd(0, div);
    set_bnd(0, p);
    
    for (let k = 0; k < iter; k++) {
        for (let i = 1; i <= N; i++) {
            for (let j = 1; j <= N; j++) {
                p[IX(i, j)] = (div[IX(i, j)] +
                    p[IX(i - 1, j)] + p[IX(i + 1, j)] +
                    p[IX(i, j - 1)] + p[IX(i, j + 1)]) / 4;
            }
        }
        set_bnd(0, p);
    }
    
    for (let i = 1; i <= N; i++) {
        for (let j = 1; j <= N; j++) {
            u[IX(i, j)] -= 0.5 * (p[IX(i + 1, j)] - p[IX(i - 1, j)]) / h;
            v[IX(i, j)] -= 0.5 * (p[IX(i, j + 1)] - p[IX(i, j - 1)]) / h;
        }
    }
    set_bnd(1, u);
    set_bnd(2, v);
}

// å¯†åº¦æ­¥è¿›
function dens_step(x, x0, u, v, diff, dt) {
    // æ·»åŠ æº
    for (let i = 0; i < x.length; i++) {
        x[i] += dt * x0[i];
    }
    
    // æ‰©æ•£
    [x, x0] = [x0, x];
    diffuse(0, x, x0, diff, dt);
    
    // å¹³æµ
    [x, x0] = [x0, x];
    advect(0, x, x0, u, v, dt);
}

// é€Ÿåº¦æ­¥è¿›
function vel_step(u, v, u0, v0, visc, dt) {
    // æ·»åŠ åŠ›
    for (let i = 0; i < u.length; i++) {
        u[i] += dt * u0[i];
        v[i] += dt * v0[i];
    }
    
    // æ‰©æ•£
    [u, u0] = [u0, u];
    diffuse(1, u, u0, visc, dt);
    [v, v0] = [v0, v];
    diffuse(2, v, v0, visc, dt);
    
    // æŠ•å½±
    project(u, v, u0, v0);
    
    // å¹³æµ
    [u, u0] = [u0, u];
    [v, v0] = [v0, v];
    advect(1, u, u0, u0, v0, dt);
    advect(2, v, v0, u0, v0, dt);
    
    // å†æ¬¡æŠ•å½±
    project(u, v, u0, v0);
}

// æ›´æ–°ç²’å­
function updateParticles() {
    const cellW = canvas.width / N;
    const cellH = canvas.height / N;
    
    particles = particles.filter(p => {
        const i = Math.floor(p.x / cellW) + 1;
        const j = Math.floor(p.y / cellH) + 1;
        
        if (i < 1 || i > N || j < 1 || j > N) return false;
        
        const idx = IX(i, j);
        p.x += u[idx] * cellW * 0.5;
        p.y += v[idx] * cellH * 0.5;
        p.life -= 0.003;
        
        return p.life > 0 && p.x > 0 && p.x < canvas.width && p.y > 0 && p.y < canvas.height;
    });
}

// æ·»åŠ ç²’å­
function addParticles(x, y, count = 5) {
    for (let i = 0; i < count && particles.length < MAX_PARTICLES; i++) {
        particles.push({
            x: x + (Math.random() - 0.5) * 20,
            y: y + (Math.random() - 0.5) * 20,
            life: 1,
            hue: (Date.now() / 50) % 360
        });
    }
}

function init() {
    canvas = document.getElementById('fluidCanvas');
    ctx = canvas.getContext('2d');
    resizeCanvas();
    renderControlPanel();
    
    canvas.addEventListener('mousedown', (e) => { mouseDown = true; updateMouse(e); });
    canvas.addEventListener('mouseup', () => { mouseDown = false; });
    canvas.addEventListener('mousemove', updateMouse);
    canvas.addEventListener('mouseleave', () => { mouseDown = false; });
    
    window.addEventListener('resize', resizeCanvas);
    
    animate();
}

function resizeCanvas() {
    canvas.width = canvas.parentElement.clientWidth;
    canvas.height = canvas.parentElement.clientHeight;
}

function updateMouse(e) {
    const rect = canvas.getBoundingClientRect();
    pmouseX = mouseX;
    pmouseY = mouseY;
    mouseX = e.clientX - rect.left;
    mouseY = e.clientY - rect.top;
}

function renderControlPanel() {
    const panel = document.getElementById('controlPanel');
    panel.innerHTML = `
        <style>
            .slider-group { margin-bottom: 10px; }
            .slider-label { display: flex; justify-content: space-between; font-size: 0.8em; color: #aaa; margin-bottom: 4px; }
            input[type="range"] { width: 100%; height: 5px; border-radius: 3px; background: #333; -webkit-appearance: none; }
            input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 14px; height: 14px; border-radius: 50%; background: #0af; cursor: pointer; }
            .btn { padding: 8px 12px; border: none; border-radius: 6px; cursor: pointer; font-size: 0.85em; transition: all 0.3s; margin: 2px; }
            .btn-primary { background: linear-gradient(135deg, #0af, #06f); color: #fff; }
            .btn-secondary { background: rgba(255,255,255,0.1); color: #fff; }
            .btn.active { box-shadow: 0 0 10px #0af; }
            .btn:hover { transform: translateY(-1px); }
            .stats { font-size: 0.75em; color: #888; line-height: 1.6; }
            .color-btn { width: 30px; height: 30px; border-radius: 50%; border: 2px solid transparent; cursor: pointer; }
            .color-btn.active { border-color: #fff; }
        </style>
        <div style="text-align:center;margin-bottom:8px;">
            <h2 style="color:#0af;font-size:1.1em;">ğŸŒŠ æµä½“åŠ¨åŠ›å­¦æ¨¡æ‹Ÿ</h2>
            <p style="color:#666;font-size:0.75em;">æ‹–æ‹½é¼ æ ‡åˆ›å»ºæµåŠ¨</p>
        </div>
        
        <div class="panel-section">
            <div class="panel-title">âš™ï¸ ç‰©ç†å‚æ•°</div>
            <div class="slider-group">
                <div class="slider-label"><span>ç²˜åº¦</span><span id="viscVal">${visc.toFixed(4)}</span></div>
                <input type="range" id="viscSlider" min="0" max="100" value="${visc * 10000}">
            </div>
            <div class="slider-group">
                <div class="slider-label"><span>æ‰©æ•£</span><span id="diffVal">${diff.toFixed(4)}</span></div>
                <input type="range" id="diffSlider" min="0" max="100" value="${diff * 10000}">
            </div>
            <div class="slider-group">
                <div class="slider-label"><span>æ—¶é—´æ­¥é•¿</span><span id="dtVal">${dt.toFixed(2)}</span></div>
                <input type="range" id="dtSlider" min="1" max="30" value="${dt * 100}">
            </div>
        </div>
        
        <div class="panel-section">
            <div class="panel-title">ğŸ¨ å¯è§†åŒ–</div>
            <div style="display:flex;flex-wrap:wrap;gap:4px;">
                <button class="btn ${colorMode==='velocity'?'btn-primary':'btn-secondary'}" onclick="setColorMode('velocity')">é€Ÿåº¦</button>
                <button class="btn ${colorMode==='vorticity'?'btn-primary':'btn-secondary'}" onclick="setColorMode('vorticity')">æ¶¡é‡</button>
                <button class="btn ${colorMode==='density'?'btn-primary':'btn-secondary'}" onclick="setColorMode('density')">å¯†åº¦</button>
            </div>
            <div style="margin-top:8px;display:flex;gap:4px;">
                <button class="btn ${showParticles?'btn-primary':'btn-secondary'}" onclick="toggleParticles()">ç²’å­</button>
                <button class="btn ${showVectors?'btn-primary':'btn-secondary'}" onclick="toggleVectors()">çŸ¢é‡</button>
            </div>
        </div>
        
        <div class="panel-section">
            <div class="panel-title">ğŸ¬ é¢„è®¾åœºæ™¯</div>
            <div style="display:flex;flex-wrap:wrap;gap:4px;">
                <button class="btn btn-secondary" onclick="presetVortex()">æ¶¡æ—‹å¯¹</button>
                <button class="btn btn-secondary" onclick="presetJet()">å°„æµ</button>
                <button class="btn btn-secondary" onclick="clearFluid()">æ¸…ç©º</button>
            </div>
        </div>
        
        <div class="panel-section">
            <div class="panel-title">ğŸ“Š ç»Ÿè®¡</div>
            <div class="stats" id="stats">
                æœ€å¤§é€Ÿåº¦: 0.00<br>
                å¹³å‡æ¶¡é‡: 0.00<br>
                ç²’å­æ•°: 0
            </div>
        </div>
        
        <div class="panel-section">
            <div class="panel-title">ğŸ’¡ è¯´æ˜</div>
            <div style="font-size:0.75em;color:#888;line-height:1.5;">
                åŸºäºStable Fluidsç®—æ³•çš„å®æ—¶æµä½“æ¨¡æ‹Ÿã€‚<br>
                <b>ç²˜åº¦</b>ï¼šæ§åˆ¶æµä½“çš„"ç²˜ç¨ åº¦"<br>
                <b>æ‰©æ•£</b>ï¼šæŸ“æ–™æ‰©æ•£é€Ÿåº¦<br>
                æ‹–æ‹½é¼ æ ‡æ–½åŠ åŠ›å¹¶æ·»åŠ æŸ“æ–™ã€‚
            </div>
        </div>
    `;
    
    document.getElementById('viscSlider').oninput = (e) => {
        visc = e.target.value / 10000;
        document.getElementById('viscVal').textContent = visc.toFixed(4);
    };
    document.getElementById('diffSlider').oninput = (e) => {
        diff = e.target.value / 10000;
        document.getElementById('diffVal').textContent = diff.toFixed(4);
    };
    document.getElementById('dtSlider').oninput = (e) => {
        dt = e.target.value / 100;
        document.getElementById('dtVal').textContent = dt.toFixed(2);
    };
}

function setColorMode(mode) {
    colorMode = mode;
    renderControlPanel();
}

function toggleParticles() {
    showParticles = !showParticles;
    renderControlPanel();
}

function toggleVectors() {
    showVectors = !showVectors;
    renderControlPanel();
}

function clearFluid() {
    u.fill(0); v.fill(0);
    u_prev.fill(0); v_prev.fill(0);
    dens.fill(0); dens_prev.fill(0);
    particles = [];
}

function presetVortex() {
    clearFluid();
    const cx = N / 2, cy = N / 2;
    const r = N / 6;
    
    for (let i = 1; i <= N; i++) {
        for (let j = 1; j <= N; j++) {
            const dx1 = i - (cx - r);
            const dy1 = j - cy;
            const dx2 = i - (cx + r);
            const dy2 = j - cy;
            
            const d1 = Math.sqrt(dx1*dx1 + dy1*dy1);
            const d2 = Math.sqrt(dx2*dx2 + dy2*dy2);
            
            if (d1 < r * 2) {
                u[IX(i,j)] += -dy1 / (d1 + 1) * 5;
                v[IX(i,j)] += dx1 / (d1 + 1) * 5;
            }
            if (d2 < r * 2) {
                u[IX(i,j)] += dy2 / (d2 + 1) * 5;
                v[IX(i,j)] += -dx2 / (d2 + 1) * 5;
            }
        }
    }
}

function presetJet() {
    clearFluid();
    for (let j = N/2 - 5; j <= N/2 + 5; j++) {
        u[IX(2, j)] = 20;
        dens[IX(2, j)] = 1;
    }
}

function simulate() {
    // æ¸…é™¤ä¸Šä¸€å¸§çš„æº
    u_prev.fill(0);
    v_prev.fill(0);
    dens_prev.fill(0);
    
    // é¼ æ ‡äº¤äº’
    if (mouseDown) {
        const cellW = canvas.width / N;
        const cellH = canvas.height / N;
        const i = Math.floor(mouseX / cellW) + 1;
        const j = Math.floor(mouseY / cellH) + 1;
        
        if (i > 0 && i <= N && j > 0 && j <= N) {
            const force = 50;
            u_prev[IX(i, j)] = (mouseX - pmouseX) * force;
            v_prev[IX(i, j)] = (mouseY - pmouseY) * force;
            dens_prev[IX(i, j)] = 10;
            
            addParticles(mouseX, mouseY, 3);
        }
    }
    
    // æ­¥è¿›æ¨¡æ‹Ÿ
    vel_step(u, v, u_prev, v_prev, visc, dt);
    dens_step(dens, dens_prev, u, v, diff, dt);
    
    // æ›´æ–°ç²’å­
    if (showParticles) updateParticles();
}

function draw() {
    const cellW = canvas.width / N;
    const cellH = canvas.height / N;
    
    // åˆ›å»ºå›¾åƒæ•°æ®
    const imageData = ctx.createImageData(canvas.width, canvas.height);
    const data = imageData.data;
    
    for (let i = 1; i <= N; i++) {
        for (let j = 1; j <= N; j++) {
            const idx = IX(i, j);
            let value = 0;
            let hue = 200;
            
            if (colorMode === 'velocity') {
                const speed = Math.sqrt(u[idx] * u[idx] + v[idx] * v[idx]);
                value = Math.min(1, speed / 10);
                hue = 200 - value * 200;
            } else if (colorMode === 'vorticity') {
                const vort = (u[IX(i, j+1)] - u[IX(i, j-1)] - v[IX(i+1, j)] + v[IX(i-1, j)]) / 2;
                value = Math.min(1, Math.abs(vort) / 5);
                hue = vort > 0 ? 0 : 240;
            } else if (colorMode === 'density') {
                value = Math.min(1, dens[idx]);
                hue = 180;
            }
            
            // å¡«å……åƒç´ 
            const startX = Math.floor((i - 1) * cellW);
            const startY = Math.floor((j - 1) * cellH);
            const endX = Math.floor(i * cellW);
            const endY = Math.floor(j * cellH);
            
            const rgb = hslToRgb(hue / 360, 0.8, value * 0.5);
            
            for (let px = startX; px < endX; px++) {
                for (let py = startY; py < endY; py++) {
                    const pidx = (py * canvas.width + px) * 4;
                    data[pidx] = rgb[0];
                    data[pidx + 1] = rgb[1];
                    data[pidx + 2] = rgb[2];
                    data[pidx + 3] = 255;
                }
            }
        }
    }
    
    ctx.putImageData(imageData, 0, 0);
    
    // ç»˜åˆ¶ç²’å­
    if (showParticles) {
        particles.forEach(p => {
            ctx.fillStyle = `hsla(${p.hue}, 100%, 60%, ${p.life})`;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
            ctx.fill();
        });
    }
    
    // ç»˜åˆ¶çŸ¢é‡åœº
    if (showVectors) {
        ctx.strokeStyle = 'rgba(255,255,255,0.3)';
        ctx.lineWidth = 1;
        const step = 8;
        
        for (let i = step; i <= N; i += step) {
            for (let j = step; j <= N; j += step) {
                const idx = IX(i, j);
                const x = (i - 0.5) * cellW;
                const y = (j - 0.5) * cellH;
                const vx = u[idx] * 3;
                const vy = v[idx] * 3;
                
                ctx.beginPath();
                ctx.moveTo(x, y);
                ctx.lineTo(x + vx, y + vy);
                ctx.stroke();
            }
        }
    }
    
    // æ›´æ–°ç»Ÿè®¡
    let maxSpeed = 0, totalVort = 0;
    for (let i = 1; i <= N; i++) {
        for (let j = 1; j <= N; j++) {
            const idx = IX(i, j);
            const speed = Math.sqrt(u[idx] * u[idx] + v[idx] * v[idx]);
            maxSpeed = Math.max(maxSpeed, speed);
            totalVort += Math.abs((u[IX(i, j+1)] - u[IX(i, j-1)] - v[IX(i+1, j)] + v[IX(i-1, j)]) / 2);
        }
    }
    
    document.getElementById('stats').innerHTML = `
        æœ€å¤§é€Ÿåº¦: ${maxSpeed.toFixed(2)}<br>
        å¹³å‡æ¶¡é‡: ${(totalVort / (N * N)).toFixed(4)}<br>
        ç²’å­æ•°: ${particles.length}
    `;
}

function hslToRgb(h, s, l) {
    let r, g, b;
    if (s === 0) {
        r = g = b = l;
    } else {
        const hue2rgb = (p, q, t) => {
            if (t < 0) t += 1;
            if (t > 1) t -= 1;
            if (t < 1/6) return p + (q - p) * 6 * t;
            if (t < 1/2) return q;
            if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
            return p;
        };
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
    }
    return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];
}

function animate() {
    simulate();
    draw();
    requestAnimationFrame(animate);
}

init();
</script>
</body>
</html>