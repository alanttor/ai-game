<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ•°æ®ç»“æ„å¡”é˜² - ç®—æ³•å­¦ä¹ æ¸¸æˆ</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ°</text></svg>">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Consolas', 'Monaco', monospace;
            background: #0a0a1a;
            color: #0ff;
            min-height: 100vh;
            overflow: hidden;
        }
        .game-container {
            display: flex;
            height: 100vh;
        }
        .game-area {
            flex: 7;
            position: relative;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 100%);
        }
        #gameCanvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .control-panel {
            flex: 3;
            background: linear-gradient(180deg, #0d0d2b 0%, #1a0a2e 100%);
            border-left: 2px solid #0ff;
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 12px;
            overflow-y: auto;
        }
        .panel-title {
            font-size: 1.2em;
            color: #f0f;
            text-shadow: 0 0 10px #f0f;
            border-bottom: 1px solid #f0f;
            padding-bottom: 8px;
            margin-bottom: 5px;
        }
</style>
</head>
<body>
<div class="game-container">
    <div class="game-area">
        <canvas id="gameCanvas"></canvas>
    </div>
    <div class="control-panel" id="controlPanel"></div>
</div>
<script>
// æ¸¸æˆå¸¸é‡
const CELL_SIZE = 50;
const PATH_COLOR = '#1a1a3a';
const GRID_COLOR = '#0ff2';

// é˜²å¾¡å¡”é…ç½®
const TOWERS = {
    stack: {
        name: 'æ ˆå¡”', icon: 'ğŸ“š', color: '#ff6b6b', cost: 50,
        damage: 25, range: 120, cooldown: 800,
        desc: 'LIFO - åè¿›å…ˆå‡ºæ”»å‡»ï¼Œä¼˜å…ˆæ”»å‡»æœ€è¿‘è¿›å…¥èŒƒå›´çš„æ•Œäºº',
        complexity: 'O(1) push/pop'
    },
    queue: {
        name: 'é˜Ÿåˆ—å¡”', icon: 'ğŸš¶', color: '#4ecdc4', cost: 50,
        damage: 20, range: 130, cooldown: 700,
        desc: 'FIFO - å…ˆè¿›å…ˆå‡ºæ”»å‡»ï¼Œä¼˜å…ˆæ”»å‡»æœ€å…ˆè¿›å…¥èŒƒå›´çš„æ•Œäºº',
        complexity: 'O(1) enqueue/dequeue'
    },
    binaryTree: {
        name: 'äºŒå‰æ ‘å¡”', icon: 'ğŸŒ²', color: '#95e1d3', cost: 80,
        damage: 35, range: 150, cooldown: 1000,
        desc: 'äºŒåˆ†æŸ¥æ‰¾æ”»å‡»ï¼Œå¿«é€Ÿå®šä½è¡€é‡æœ€é«˜çš„ç›®æ ‡',
        complexity: 'O(log n) æŸ¥æ‰¾'
    },
    hashTable: {
        name: 'å“ˆå¸Œè¡¨å¡”', icon: '#ï¸âƒ£', color: '#f9ed69', cost: 100,
        damage: 50, range: 100, cooldown: 500,
        desc: 'O(1)æé€Ÿæ”»å‡»ï¼Œä½†æœ‰10%æ¦‚ç‡å‘ç”Ÿå“ˆå¸Œç¢°æ’ï¼ˆmissï¼‰',
        complexity: 'O(1) å¹³å‡'
    },
    heap: {
        name: 'å †å¡”', icon: 'â›°ï¸', color: '#f08a5d', cost: 120,
        damage: 40, range: 140, cooldown: 900,
        desc: 'ä¼˜å…ˆé˜Ÿåˆ—æ”»å‡»ï¼Œå§‹ç»ˆæ”»å‡»èŒƒå›´å†…æœ€å¼ºçš„æ•Œäºº',
        complexity: 'O(log n) æ’å…¥/åˆ é™¤'
    },
    graph: {
        name: 'å›¾å¡”', icon: 'ğŸ•¸ï¸', color: '#b83b5e', cost: 150,
        damage: 20, range: 160, cooldown: 1200,
        desc: 'BFSè¿é”æ”»å‡»ï¼Œä¼¤å®³å¯ä¼ é€’ç»™ç›¸é‚»æ•Œäººï¼ˆæœ€å¤š3ä¸ªï¼‰',
        complexity: 'O(V+E) éå†'
    }
};

// æ•Œäººé…ç½®
const ENEMIES = {
    array: {
        name: 'æ•°ç»„æµ', color: '#ff9f43', hp: 80, speed: 1.5, reward: 10,
        desc: 'è¿ç»­å†…å­˜ï¼Œç§»åŠ¨è§„å¾‹ä½†éš¾ä»¥ä¸­é€”æ‹¦æˆª'
    },
    linkedList: {
        name: 'é“¾è¡¨æµ', color: '#00d2d3', hp: 60, speed: 2, reward: 12,
        desc: 'èŠ‚ç‚¹åˆ†æ•£ï¼Œçµæ´»ç§»åŠ¨ä½†æ•´ä½“è¾ƒè„†å¼±'
    },
    tree: {
        name: 'æ ‘æ•Œäºº', color: '#10ac84', hp: 150, speed: 1, reward: 25,
        desc: 'å±‚çº§ç»“æ„ï¼Œéœ€è¦ä»æ ¹èŠ‚ç‚¹å¼€å§‹æ”»å‡»'
    },
    graph: {
        name: 'å›¾æ•Œäºº', color: '#ee5a24', hp: 200, speed: 0.8, reward: 40,
        desc: 'å¤æ‚è¿æ¥ï¼Œå¯èƒ½èµ°æœ€çŸ­è·¯å¾„ç»•è¿‡é˜²å¾¡'
    }
};

// å…³å¡é…ç½®
const LEVELS = [
    { name: 'æ•°ç»„å…¥é—¨', waves: [{type:'array',count:8,interval:1000}], tip: 'ä½¿ç”¨æ ˆæˆ–é˜Ÿåˆ—å¡”å¤„ç†ç®€å•æ•°ç»„æµ' },
    { name: 'é“¾è¡¨æŒ‘æˆ˜', waves: [{type:'linkedList',count:10,interval:800}], tip: 'é“¾è¡¨æ•Œäººé€Ÿåº¦å¿«ï¼Œéœ€è¦æ›´å¤šé˜²å¾¡å¡”' },
    { name: 'æ··åˆæ•°æ®', waves: [{type:'array',count:5,interval:1000},{type:'linkedList',count:5,interval:800}], tip: 'ä¸åŒæ•Œäººéœ€è¦ä¸åŒç­–ç•¥' },
    { name: 'æ ‘ç»“æ„', waves: [{type:'tree',count:5,interval:2000}], tip: 'äºŒå‰æ ‘å¡”å¯¹æ ‘æ•Œäººæœ‰é¢å¤–ä¼¤å®³' },
    { name: 'å›¾è®ºå…¥é—¨', waves: [{type:'graph',count:3,interval:3000}], tip: 'å›¾å¡”çš„è¿é”æ”»å‡»å¯¹å›¾æ•Œäººå¾ˆæœ‰æ•ˆ' },
    { name: 'ç®—æ³•å¤§æˆ˜', waves: [{type:'array',count:5,interval:1000},{type:'tree',count:3,interval:2000},{type:'graph',count:2,interval:3000}], tip: 'ç»¼åˆè¿ç”¨æ‰€æœ‰æ•°æ®ç»“æ„ï¼' }
];

// æ¸¸æˆçŠ¶æ€
let canvas, ctx;
let gameState = {
    money: 200,
    lives: 20,
    level: 0,
    wave: 0,
    score: 0,
    towers: [],
    enemies: [],
    projectiles: [],
    effects: [],
    selectedTower: null,
    placingTower: null,
    paused: false,
    gameOver: false,
    waveInProgress: false,
    enemiesSpawned: 0,
    lastSpawnTime: 0,
    path: [],
    gridCols: 0,
    gridRows: 0,
    stats: { towersBuilt: 0, enemiesKilled: 0, damageDealt: 0 }
};

// åˆå§‹åŒ–
function init() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');
    resizeCanvas();
    generatePath();
    renderControlPanel();
    requestAnimationFrame(gameLoop);
    window.addEventListener('resize', () => { resizeCanvas(); generatePath(); });
    canvas.addEventListener('click', handleCanvasClick);
    canvas.addEventListener('mousemove', handleCanvasMove);
}

function resizeCanvas() {
    const rect = canvas.parentElement.getBoundingClientRect();
    canvas.width = rect.width;
    canvas.height = rect.height;
    gameState.gridCols = Math.floor(canvas.width / CELL_SIZE);
    gameState.gridRows = Math.floor(canvas.height / CELL_SIZE);
}

// ç”Ÿæˆè·¯å¾„
function generatePath() {
    const cols = gameState.gridCols;
    const rows = gameState.gridRows;
    const path = [];
    
    // åˆ›å»ºSå½¢è·¯å¾„
    let x = 0, y = Math.floor(rows / 2);
    path.push({x, y});
    
    // å‘å³
    for (let i = 0; i < Math.floor(cols * 0.3); i++) {
        x++; path.push({x, y});
    }
    // å‘ä¸Š
    for (let i = 0; i < Math.floor(rows * 0.3); i++) {
        y--; path.push({x, y});
    }
    // å‘å³
    for (let i = 0; i < Math.floor(cols * 0.3); i++) {
        x++; path.push({x, y});
    }
    // å‘ä¸‹
    for (let i = 0; i < Math.floor(rows * 0.6); i++) {
        y++; path.push({x, y});
    }
    // å‘å³åˆ°ç»ˆç‚¹
    while (x < cols - 1) {
        x++; path.push({x, y});
    }
    
    gameState.path = path;
}

// æ¸²æŸ“æ§åˆ¶é¢æ¿
function renderControlPanel() {
    const panel = document.getElementById('controlPanel');
    const level = LEVELS[gameState.level] || LEVELS[0];
    
    panel.innerHTML = `
        <div class="panel-title">ğŸ“Š æ¸¸æˆçŠ¶æ€</div>
        <div class="stats-grid">
            <div class="stat-item"><span class="stat-icon">ğŸ’°</span><span id="money">${gameState.money}</span></div>
            <div class="stat-item"><span class="stat-icon">â¤ï¸</span><span id="lives">${gameState.lives}</span></div>
            <div class="stat-item"><span class="stat-icon">ğŸ†</span><span id="score">${gameState.score}</span></div>
            <div class="stat-item"><span class="stat-icon">ğŸ“ˆ</span>å…³å¡ <span id="levelNum">${gameState.level + 1}</span></div>
        </div>
        
        <div class="panel-title">ğŸ—ï¸ é˜²å¾¡å¡”</div>
        <div class="tower-list" id="towerList"></div>
        
        <div class="panel-title">ğŸ“– ç®—æ³•æç¤º</div>
        <div class="tip-box" id="tipBox">${level.tip}</div>
        
        <div class="panel-title">ğŸ® æ§åˆ¶</div>
        <div class="control-buttons">
            <button class="ctrl-btn" id="startWaveBtn" onclick="startWave()">â–¶ï¸ å¼€å§‹æ³¢æ¬¡</button>
            <button class="ctrl-btn" id="pauseBtn" onclick="togglePause()">${gameState.paused ? 'â–¶ï¸ ç»§ç»­' : 'â¸ï¸ æš‚åœ'}</button>
        </div>
        
        <div class="panel-title">ğŸ“š æ•°æ®ç»“æ„è¯´æ˜</div>
        <div class="info-box" id="infoBox">é€‰æ‹©é˜²å¾¡å¡”æŸ¥çœ‹è¯¦æƒ…</div>
    `;
    
    // æ·»åŠ æ ·å¼
    if (!document.getElementById('panelStyles')) {
        const style = document.createElement('style');
        style.id = 'panelStyles';
        style.textContent = `
            .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
            .stat-item { background: #1a1a3a; padding: 10px; border-radius: 8px; display: flex; align-items: center; gap: 8px; border: 1px solid #0ff3; }
            .stat-icon { font-size: 1.2em; }
            .tower-list { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
            .tower-btn { background: #1a1a3a; border: 2px solid #333; border-radius: 8px; padding: 10px; cursor: pointer; transition: all 0.3s; text-align: center; }
            .tower-btn:hover { border-color: #0ff; transform: scale(1.05); }
            .tower-btn.selected { border-color: #f0f; box-shadow: 0 0 15px #f0f5; }
            .tower-btn.disabled { opacity: 0.5; cursor: not-allowed; }
            .tower-icon { font-size: 1.8em; display: block; margin-bottom: 5px; }
            .tower-name { font-size: 0.85em; color: #fff; }
            .tower-cost { font-size: 0.75em; color: #ffd700; }
            .tip-box { background: #1a1a3a; padding: 12px; border-radius: 8px; border-left: 3px solid #0ff; font-size: 0.9em; line-height: 1.5; }
            .info-box { background: #1a1a3a; padding: 12px; border-radius: 8px; font-size: 0.85em; line-height: 1.6; min-height: 100px; }
            .ctrl-btn { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; color: #fff; padding: 12px 20px; border-radius: 8px; cursor: pointer; font-size: 1em; width: 100%; margin-bottom: 8px; transition: all 0.3s; }
            .ctrl-btn:hover { transform: translateY(-2px); box-shadow: 0 5px 20px #667eea55; }
            .ctrl-btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
            .control-buttons { display: flex; flex-direction: column; }
        `;
        document.head.appendChild(style);
    }
    
    // æ¸²æŸ“é˜²å¾¡å¡”æŒ‰é’®
    const towerList = document.getElementById('towerList');
    Object.entries(TOWERS).forEach(([key, tower]) => {
        const btn = document.createElement('div');
        btn.className = `tower-btn ${gameState.money < tower.cost ? 'disabled' : ''} ${gameState.placingTower === key ? 'selected' : ''}`;
        btn.innerHTML = `
            <span class="tower-icon">${tower.icon}</span>
            <span class="tower-name">${tower.name}</span>
            <span class="tower-cost">ğŸ’°${tower.cost}</span>
        `;
        btn.onclick = () => selectTower(key);
        btn.onmouseenter = () => showTowerInfo(key);
        towerList.appendChild(btn);
    });
}

// é€‰æ‹©é˜²å¾¡å¡”
function selectTower(type) {
    if (gameState.money < TOWERS[type].cost) return;
    gameState.placingTower = gameState.placingTower === type ? null : type;
    renderControlPanel();
}

// æ˜¾ç¤ºé˜²å¾¡å¡”ä¿¡æ¯
function showTowerInfo(type) {
    const tower = TOWERS[type];
    document.getElementById('infoBox').innerHTML = `
        <div style="color:${tower.color};font-size:1.1em;margin-bottom:8px;">${tower.icon} ${tower.name}</div>
        <div style="margin-bottom:5px;">${tower.desc}</div>
        <div style="color:#0ff;">æ—¶é—´å¤æ‚åº¦: ${tower.complexity}</div>
        <div style="color:#aaa;font-size:0.8em;margin-top:8px;">
            ä¼¤å®³: ${tower.damage} | èŒƒå›´: ${tower.range}px | å†·å´: ${tower.cooldown}ms
        </div>
    `;
}

// ç”»å¸ƒç‚¹å‡»
function handleCanvasClick(e) {
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const gridX = Math.floor(x / CELL_SIZE);
    const gridY = Math.floor(y / CELL_SIZE);
    
    if (gameState.placingTower) {
        placeTower(gridX, gridY);
    } else {
        // é€‰æ‹©å·²æœ‰å¡”
        const tower = gameState.towers.find(t => t.gridX === gridX && t.gridY === gridY);
        if (tower) {
            gameState.selectedTower = tower;
            showTowerInfo(tower.type);
        } else {
            gameState.selectedTower = null;
        }
    }
}

// ç”»å¸ƒç§»åŠ¨
let mousePos = {x: 0, y: 0};
function handleCanvasMove(e) {
    const rect = canvas.getBoundingClientRect();
    mousePos.x = e.clientX - rect.left;
    mousePos.y = e.clientY - rect.top;
}

// æ”¾ç½®é˜²å¾¡å¡”
function placeTower(gridX, gridY) {
    const type = gameState.placingTower;
    const tower = TOWERS[type];
    
    // æ£€æŸ¥æ˜¯å¦åœ¨è·¯å¾„ä¸Š
    if (gameState.path.some(p => p.x === gridX && p.y === gridY)) {
        addEffect(gridX * CELL_SIZE + CELL_SIZE/2, gridY * CELL_SIZE + CELL_SIZE/2, 'âŒ', '#f00');
        return;
    }
    
    // æ£€æŸ¥æ˜¯å¦å·²æœ‰å¡”
    if (gameState.towers.some(t => t.gridX === gridX && t.gridY === gridY)) {
        addEffect(gridX * CELL_SIZE + CELL_SIZE/2, gridY * CELL_SIZE + CELL_SIZE/2, 'âŒ', '#f00');
        return;
    }
    
    // æ£€æŸ¥è¾¹ç•Œ
    if (gridX < 0 || gridX >= gameState.gridCols || gridY < 0 || gridY >= gameState.gridRows) return;
    
    // æ”¾ç½®å¡”
    gameState.towers.push({
        type,
        gridX,
        gridY,
        x: gridX * CELL_SIZE + CELL_SIZE / 2,
        y: gridY * CELL_SIZE + CELL_SIZE / 2,
        lastAttack: 0,
        kills: 0,
        targetQueue: [] // ç”¨äºé˜Ÿåˆ—å¡”
    });
    
    gameState.money -= tower.cost;
    gameState.stats.towersBuilt++;
    gameState.placingTower = null;
    addEffect(gridX * CELL_SIZE + CELL_SIZE/2, gridY * CELL_SIZE + CELL_SIZE/2, 'âœ¨', tower.color);
    renderControlPanel();
}

// å¼€å§‹æ³¢æ¬¡
function startWave() {
    if (gameState.waveInProgress || gameState.gameOver) return;
    
    const level = LEVELS[gameState.level];
    if (!level) {
        // æ¸¸æˆèƒœåˆ©
        gameState.gameOver = true;
        showGameEnd(true);
        return;
    }
    
    gameState.waveInProgress = true;
    gameState.enemiesSpawned = 0;
    gameState.wave = 0;
    document.getElementById('startWaveBtn').disabled = true;
    document.getElementById('tipBox').textContent = `âš”ï¸ æ³¢æ¬¡è¿›è¡Œä¸­...`;
}

// ç”Ÿæˆæ•Œäºº
function spawnEnemy() {
    const level = LEVELS[gameState.level];
    if (!level || gameState.wave >= level.waves.length) return;
    
    const wave = level.waves[gameState.wave];
    const now = Date.now();
    
    if (gameState.enemiesSpawned < wave.count && now - gameState.lastSpawnTime > wave.interval) {
        const enemyConfig = ENEMIES[wave.type];
        const startPos = gameState.path[0];
        
        gameState.enemies.push({
            type: wave.type,
            x: startPos.x * CELL_SIZE + CELL_SIZE / 2,
            y: startPos.y * CELL_SIZE + CELL_SIZE / 2,
            hp: enemyConfig.hp,
            maxHp: enemyConfig.hp,
            speed: enemyConfig.speed,
            reward: enemyConfig.reward,
            pathIndex: 0,
            color: enemyConfig.color
        });
        
        gameState.enemiesSpawned++;
        gameState.lastSpawnTime = now;
    }
    
    // æ£€æŸ¥æ³¢æ¬¡å®Œæˆ
    if (gameState.enemiesSpawned >= wave.count && gameState.enemies.length === 0) {
        gameState.wave++;
        gameState.enemiesSpawned = 0;
        
        if (gameState.wave >= level.waves.length) {
            // å…³å¡å®Œæˆ
            gameState.waveInProgress = false;
            gameState.level++;
            gameState.money += 50; // å…³å¡å¥–åŠ±
            
            if (gameState.level >= LEVELS.length) {
                gameState.gameOver = true;
                showGameEnd(true);
            } else {
                document.getElementById('startWaveBtn').disabled = false;
                document.getElementById('tipBox').textContent = `âœ… å…³å¡å®Œæˆï¼å‡†å¤‡ä¸‹ä¸€å…³...`;
                renderControlPanel();
            }
        }
    }
}

// æ›´æ–°æ•Œäºº
function updateEnemies() {
    gameState.enemies.forEach((enemy, index) => {
        if (enemy.hp <= 0) {
            // æ•Œäººæ­»äº¡
            gameState.money += enemy.reward;
            gameState.score += enemy.reward * 10;
            gameState.stats.enemiesKilled++;
            addEffect(enemy.x, enemy.y, 'ğŸ’¥', enemy.color);
            gameState.enemies.splice(index, 1);
            renderControlPanel();
            return;
        }
        
        // æ²¿è·¯å¾„ç§»åŠ¨
        const targetPath = gameState.path[enemy.pathIndex + 1];
        if (!targetPath) {
            // åˆ°è¾¾ç»ˆç‚¹
            gameState.lives--;
            gameState.enemies.splice(index, 1);
            addEffect(enemy.x, enemy.y, 'ğŸ’”', '#f00');
            renderControlPanel();
            
            if (gameState.lives <= 0) {
                gameState.gameOver = true;
                showGameEnd(false);
            }
            return;
        }
        
        const targetX = targetPath.x * CELL_SIZE + CELL_SIZE / 2;
        const targetY = targetPath.y * CELL_SIZE + CELL_SIZE / 2;
        const dx = targetX - enemy.x;
        const dy = targetY - enemy.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        if (dist < enemy.speed * 2) {
            enemy.pathIndex++;
        } else {
            enemy.x += (dx / dist) * enemy.speed;
            enemy.y += (dy / dist) * enemy.speed;
        }
    });
}

// æ›´æ–°é˜²å¾¡å¡”æ”»å‡»
function updateTowers() {
    const now = Date.now();
    
    gameState.towers.forEach(tower => {
        const config = TOWERS[tower.type];
        if (now - tower.lastAttack < config.cooldown) return;
        
        // æ‰¾åˆ°èŒƒå›´å†…çš„æ•Œäºº
        const enemiesInRange = gameState.enemies.filter(e => {
            const dx = e.x - tower.x;
            const dy = e.y - tower.y;
            return Math.sqrt(dx * dx + dy * dy) <= config.range;
        });
        
        if (enemiesInRange.length === 0) return;
        
        let target = null;
        let damage = config.damage;
        
        // æ ¹æ®å¡”ç±»å‹é€‰æ‹©ç›®æ ‡
        switch (tower.type) {
            case 'stack':
                // åè¿›å…ˆå‡º - æœ€è¿‘è¿›å…¥èŒƒå›´çš„
                target = enemiesInRange[enemiesInRange.length - 1];
                break;
            case 'queue':
                // å…ˆè¿›å…ˆå‡º - æœ€å…ˆè¿›å…¥èŒƒå›´çš„
                target = enemiesInRange[0];
                break;
            case 'binaryTree':
                // äºŒåˆ†æŸ¥æ‰¾ - è¡€é‡æœ€é«˜çš„
                target = enemiesInRange.reduce((a, b) => a.hp > b.hp ? a : b);
                // å¯¹æ ‘æ•Œäººé¢å¤–ä¼¤å®³
                if (target.type === 'tree') damage *= 1.5;
                break;
            case 'hashTable':
                // O(1)æ”»å‡»ï¼Œä½†æœ‰ç¢°æ’æ¦‚ç‡
                if (Math.random() < 0.1) {
                    addEffect(tower.x, tower.y - 20, 'ç¢°æ’!', '#ff0');
                    tower.lastAttack = now;
                    return;
                }
                target = enemiesInRange[Math.floor(Math.random() * enemiesInRange.length)];
                break;
            case 'heap':
                // ä¼˜å…ˆé˜Ÿåˆ— - æ”»å‡»æœ€å¼ºçš„ï¼ˆè¡€é‡æœ€é«˜ï¼‰
                target = enemiesInRange.reduce((a, b) => a.maxHp > b.maxHp ? a : b);
                break;
            case 'graph':
                // BFSè¿é”æ”»å‡»
                target = enemiesInRange[0];
                // è¿é”ä¼¤å®³
                const chainTargets = enemiesInRange.slice(1, 4);
                chainTargets.forEach(e => {
                    e.hp -= damage * 0.5;
                    addProjectile(tower, e, config.color, true);
                });
                // å¯¹å›¾æ•Œäººé¢å¤–ä¼¤å®³
                if (target.type === 'graph') damage *= 1.5;
                break;
        }
        
        if (target) {
            target.hp -= damage;
            gameState.stats.damageDealt += damage;
            tower.lastAttack = now;
            addProjectile(tower, target, config.color);
            
            if (target.hp <= 0) tower.kills++;
        }
    });
}

// æ·»åŠ æŠ•å°„ç‰©
function addProjectile(tower, target, color, isChain = false) {
    gameState.projectiles.push({
        x: tower.x,
        y: tower.y,
        targetX: target.x,
        targetY: target.y,
        color,
        isChain,
        progress: 0
    });
}

// æ›´æ–°æŠ•å°„ç‰©
function updateProjectiles() {
    gameState.projectiles = gameState.projectiles.filter(p => {
        p.progress += 0.15;
        return p.progress < 1;
    });
}

// æ·»åŠ ç‰¹æ•ˆ
function addEffect(x, y, text, color) {
    gameState.effects.push({
        x, y, text, color,
        life: 1,
        vy: -2
    });
}

// æ›´æ–°ç‰¹æ•ˆ
function updateEffects() {
    gameState.effects = gameState.effects.filter(e => {
        e.life -= 0.02;
        e.y += e.vy;
        return e.life > 0;
    });
}

// æš‚åœ/ç»§ç»­
function togglePause() {
    gameState.paused = !gameState.paused;
    renderControlPanel();
}

// æ¸¸æˆç»“æŸ
function showGameEnd(won) {
    const overlay = document.createElement('div');
    overlay.style.cssText = `
        position: fixed; top: 0; left: 0; right: 0; bottom: 0;
        background: rgba(0,0,0,0.9); display: flex; align-items: center;
        justify-content: center; z-index: 1000; flex-direction: column;
    `;
    overlay.innerHTML = `
        <div style="font-size: 4em; margin-bottom: 20px;">${won ? 'ğŸ‰' : 'ğŸ’€'}</div>
        <div style="font-size: 2em; color: ${won ? '#0f0' : '#f00'}; margin-bottom: 20px;">
            ${won ? 'èƒœåˆ©ï¼æ‰€æœ‰å…³å¡å®Œæˆï¼' : 'æ¸¸æˆç»“æŸ'}
        </div>
        <div style="color: #0ff; font-size: 1.2em; margin-bottom: 30px;">
            å¾—åˆ†: ${gameState.score} | å‡»æ€: ${gameState.stats.enemiesKilled} | å»ºé€ : ${gameState.stats.towersBuilt}
        </div>
        <button onclick="location.reload()" style="
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none; color: #fff; padding: 15px 40px; border-radius: 10px;
            font-size: 1.2em; cursor: pointer;
        ">é‡æ–°å¼€å§‹</button>
    `;
    document.body.appendChild(overlay);
}

// æ¸²æŸ“æ¸¸æˆ
function render() {
    ctx.fillStyle = '#0a0a1a';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // ç»˜åˆ¶ç½‘æ ¼
    ctx.strokeStyle = GRID_COLOR;
    ctx.lineWidth = 1;
    for (let x = 0; x <= canvas.width; x += CELL_SIZE) {
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }
    for (let y = 0; y <= canvas.height; y += CELL_SIZE) {
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width, y);
        ctx.stroke();
    }
    
    // ç»˜åˆ¶è·¯å¾„
    ctx.fillStyle = PATH_COLOR;
    gameState.path.forEach(p => {
        ctx.fillRect(p.x * CELL_SIZE, p.y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
    });
    
    // ç»˜åˆ¶è·¯å¾„æ–¹å‘æŒ‡ç¤º
    ctx.strokeStyle = '#0ff3';
    ctx.lineWidth = 2;
    ctx.beginPath();
    gameState.path.forEach((p, i) => {
        const x = p.x * CELL_SIZE + CELL_SIZE / 2;
        const y = p.y * CELL_SIZE + CELL_SIZE / 2;
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    });
    ctx.stroke();
    
    // ç»˜åˆ¶èµ·ç‚¹å’Œç»ˆç‚¹
    const start = gameState.path[0];
    const end = gameState.path[gameState.path.length - 1];
    ctx.font = '24px Arial';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('ğŸšª', start.x * CELL_SIZE + CELL_SIZE/2, start.y * CELL_SIZE + CELL_SIZE/2);
    ctx.fillText('ğŸ ', end.x * CELL_SIZE + CELL_SIZE/2, end.y * CELL_SIZE + CELL_SIZE/2);
    
    // ç»˜åˆ¶é˜²å¾¡å¡”
    gameState.towers.forEach(tower => {
        const config = TOWERS[tower.type];
        
        // æ”»å‡»èŒƒå›´ï¼ˆé€‰ä¸­æ—¶æ˜¾ç¤ºï¼‰
        if (gameState.selectedTower === tower || gameState.placingTower === tower.type) {
            ctx.beginPath();
            ctx.arc(tower.x, tower.y, config.range, 0, Math.PI * 2);
            ctx.fillStyle = config.color + '15';
            ctx.fill();
            ctx.strokeStyle = config.color + '50';
            ctx.stroke();
        }
        
        // å¡”åº•åº§
        ctx.fillStyle = '#1a1a3a';
        ctx.beginPath();
        ctx.arc(tower.x, tower.y, CELL_SIZE * 0.4, 0, Math.PI * 2);
        ctx.fill();
        ctx.strokeStyle = config.color;
        ctx.lineWidth = 2;
        ctx.stroke();
        
        // å¡”å›¾æ ‡
        ctx.font = '28px Arial';
        ctx.fillText(config.icon, tower.x, tower.y);
    });
    
    // ç»˜åˆ¶æ”¾ç½®é¢„è§ˆ
    if (gameState.placingTower) {
        const gridX = Math.floor(mousePos.x / CELL_SIZE);
        const gridY = Math.floor(mousePos.y / CELL_SIZE);
        const config = TOWERS[gameState.placingTower];
        const isValid = !gameState.path.some(p => p.x === gridX && p.y === gridY) &&
                       !gameState.towers.some(t => t.gridX === gridX && t.gridY === gridY);
        
        ctx.globalAlpha = 0.5;
        ctx.beginPath();
        ctx.arc(gridX * CELL_SIZE + CELL_SIZE/2, gridY * CELL_SIZE + CELL_SIZE/2, config.range, 0, Math.PI * 2);
        ctx.fillStyle = isValid ? config.color + '20' : '#f002';
        ctx.fill();
        ctx.strokeStyle = isValid ? config.color : '#f00';
        ctx.stroke();
        
        ctx.font = '28px Arial';
        ctx.fillText(config.icon, gridX * CELL_SIZE + CELL_SIZE/2, gridY * CELL_SIZE + CELL_SIZE/2);
        ctx.globalAlpha = 1;
    }
    
    // ç»˜åˆ¶æ•Œäºº
    gameState.enemies.forEach(enemy => {
        // æ•Œäººèº«ä½“
        ctx.fillStyle = enemy.color;
        ctx.beginPath();
        ctx.arc(enemy.x, enemy.y, 15, 0, Math.PI * 2);
        ctx.fill();
        
        // æ•Œäººç±»å‹æ ‡è¯†
        const icons = { array: '[]', linkedList: 'â†’', tree: 'ğŸŒ³', graph: 'â—ˆ' };
        ctx.fillStyle = '#fff';
        ctx.font = '12px Arial';
        ctx.fillText(icons[enemy.type] || '?', enemy.x, enemy.y + 4);
        
        // è¡€æ¡
        const hpWidth = 30;
        const hpHeight = 4;
        ctx.fillStyle = '#333';
        ctx.fillRect(enemy.x - hpWidth/2, enemy.y - 25, hpWidth, hpHeight);
        ctx.fillStyle = enemy.hp > enemy.maxHp * 0.3 ? '#0f0' : '#f00';
        ctx.fillRect(enemy.x - hpWidth/2, enemy.y - 25, hpWidth * (enemy.hp / enemy.maxHp), hpHeight);
    });
    
    // ç»˜åˆ¶æŠ•å°„ç‰©
    gameState.projectiles.forEach(p => {
        const x = p.x + (p.targetX - p.x) * p.progress;
        const y = p.y + (p.targetY - p.y) * p.progress;
        
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(x, y, p.isChain ? 4 : 6, 0, Math.PI * 2);
        ctx.fill();
        
        // æ‹–å°¾
        ctx.strokeStyle = p.color + '80';
        ctx.lineWidth = p.isChain ? 2 : 3;
        ctx.beginPath();
        ctx.moveTo(p.x, p.y);
        ctx.lineTo(x, y);
        ctx.stroke();
    });
    
    // ç»˜åˆ¶ç‰¹æ•ˆ
    gameState.effects.forEach(e => {
        ctx.globalAlpha = e.life;
        ctx.fillStyle = e.color;
        ctx.font = '20px Arial';
        ctx.fillText(e.text, e.x, e.y);
        ctx.globalAlpha = 1;
    });
    
    // æš‚åœæç¤º
    if (gameState.paused) {
        ctx.fillStyle = 'rgba(0,0,0,0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ctx.fillStyle = '#0ff';
        ctx.font = '48px Arial';
        ctx.fillText('â¸ï¸ æš‚åœ', canvas.width/2, canvas.height/2);
    }
}

// æ¸¸æˆä¸»å¾ªç¯
function gameLoop() {
    if (!gameState.paused && !gameState.gameOver) {
        if (gameState.waveInProgress) {
            spawnEnemy();
        }
        updateEnemies();
        updateTowers();
        updateProjectiles();
        updateEffects();
    }
    render();
    requestAnimationFrame(gameLoop);
}

// å¯åŠ¨æ¸¸æˆ
init();
</script>
</body>
</html>